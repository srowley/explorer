searchNodes=[{"doc":"Explorer brings series (one-dimensional) and dataframes (two-dimensional) for fast data exploration to Elixir. Most of the functionality in Explorer is in Explorer.DataFrame and Explorer.Series . Refer to those modules for more in-depth documentation.","ref":"Explorer.html","title":"Explorer","type":"module"},{"doc":"The DataFrame struct and API. Dataframes are two-dimensional tabular data structures similar to a spreadsheet. For example, the Iris dataset: iex&gt; Explorer.Datasets . iris ( ) # Explorer.DataFrame &lt; Polars [ 150 x 5 ] sepal_length float [ 5.1 , 4.9 , 4.7 , 4.6 , 5.0 , ... ] sepal_width float [ 3.5 , 3.0 , 3.2 , 3.1 , 3.6 , ... ] petal_length float [ 1.4 , 1.4 , 1.3 , 1.5 , 1.4 , ... ] petal_width float [ 0.2 , 0.2 , 0.2 , 0.2 , 0.2 , ... ] species string [ &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , &quot;Iris-setosa&quot; , ... ] &gt; This dataframe has 150 rows and five columns. Each column is an Explorer.Series of the same size (150): iex&gt; df = Explorer.Datasets . iris ( ) iex&gt; df [ &quot;sepal_length&quot; ] # Explorer.Series &lt; float [ 150 ] [ 5.1 , 4.9 , 4.7 , 4.6 , 5.0 , 5.4 , 4.6 , 5.0 , 4.4 , 4.9 , 5.4 , 4.8 , 4.8 , 4.3 , 5.8 , 5.7 , 5.4 , 5.1 , 5.7 , 5.1 , 5.4 , 5.1 , 4.6 , 5.1 , 4.8 , 5.0 , 5.0 , 5.2 , 5.2 , 4.7 , 4.8 , 5.4 , 5.2 , 5.5 , 4.9 , 5.0 , 5.5 , 4.9 , 4.4 , 5.1 , 5.0 , 4.5 , 4.4 , 5.0 , 5.1 , 4.8 , 5.1 , 4.6 , 5.3 , 5.0 , ... ] &gt; Creating dataframes Dataframes can be created from normal Elixir objects. The main ways you might do this are from_columns/1 and from_rows/1 . For example: iex&gt; Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; ] , b : [ 1 , 2 ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; ] b integer [ 1 , 2 ] &gt; Verbs Explorer uses the idea of a consistent set of SQL-like verbs like dplyr which can help solve common data manipulation challenges. These are split into single table verbs and multiple table verbs. Single table verbs Single table verbs are (unsurprisingly) used for manipulating a single dataframe. These are: select/3 for picking variables filter/2 for picking rows based on predicates mutate/2 for adding or replacing columns that are functions of existing columns arrange/2 for changing the ordering of rows distinct/2 for picking unique rows summarise/2 for reducing multiple rows down to a single summary pivot_longer/3 and pivot_wider/4 for massaging dataframes into longer or wider forms, respectively Each of these combine with Explorer.DataFrame.group_by/2 for operating by group. Multiple table verbs Multiple table verbs are used for combining tables. These are: join/3 for performing SQL-like joins concat_rows/1 for vertically &quot;stacking&quot; dataframes IO Explorer supports reading and writing of: delimited files (such as CSV) Parquet Arrow IPC Newline Delimited JSON The convention Explorer uses is to have from_* and to_* functions to read and write to files in the formats above. load_* and dump_* versions are also available to read and write those formats directly in memory. Access In addition to this &quot;grammar&quot; of data manipulation, you'll find useful functions for slicing and dicing dataframes such as pull/2 , head/2 , sample/3 , slice/3 , and take/2 . Explorer.DataFrame also implements the Access behaviour (also known as the brackets syntax). This should be familiar for users coming from other language with dataframes such as R or Python. For example: iex&gt; df = Explorer.Datasets . wine ( ) iex&gt; df [ &quot;class&quot; ] # Explorer.Series &lt; integer [ 178 ] [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , ... ] &gt;","ref":"Explorer.DataFrame.html","title":"Explorer.DataFrame","type":"module"},{"doc":"Arranges/sorts rows by columns. Examples A single column name will sort ascending by that column: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . arrange ( df , &quot;a&quot; ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 3 , 1 , 2 ] &gt; You can also sort descending: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . arrange ( df , desc : &quot;a&quot; ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;c&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 2 , 1 , 3 ] &gt; Sorting by more than one column sorts them in the order they are entered: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . arrange ( df , asc : &quot;total&quot; , desc : &quot;country&quot; ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2010 , 2012 , 2011 , 2013 , 2014 , ... ] country string [ &quot;ZIMBABWE&quot; , &quot;ZIMBABWE&quot; , &quot;ZIMBABWE&quot; , &quot;ZIMBABWE&quot; , &quot;ZIMBABWE&quot; , ... ] total integer [ 2121 , 2125 , 2608 , 3184 , 3278 , ... ] solid_fuel integer [ 1531 , 917 , 1584 , 1902 , 2097 , ... ] liquid_fuel integer [ 481 , 1006 , 888 , 1119 , 1005 , ... ] gas_fuel integer [ 0 , 0 , 0 , 0 , 0 , ... ] cement integer [ 109 , 201 , 136 , 162 , 177 , ... ] gas_flaring integer [ 0 , 0 , 0 , 0 , 0 , ... ] per_capita float [ 0.15 , 0.15 , 0.18 , 0.21 , 0.22 , ... ] bunker_fuels integer [ 7 , 9 , 8 , 9 , 9 , ... ] &gt;","ref":"Explorer.DataFrame.html#arrange/2","title":"Explorer.DataFrame.arrange/2","type":"function"},{"doc":"This collects the lazy data frame into an eager one, computing the query. If already eager, this is a noop.","ref":"Explorer.DataFrame.html#collect/1","title":"Explorer.DataFrame.collect/1","type":"function"},{"doc":"Combine two or more dataframes row-wise (stack). Column names and dtypes must match. The only exception is for numeric columns that can be mixed together, and casted automatically to float columns. Examples iex&gt; df1 = Explorer.DataFrame . new ( x : [ 1 , 2 , 3 ] , y : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; df2 = Explorer.DataFrame . new ( x : [ 4 , 5 , 6 ] , y : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . concat_rows ( [ df1 , df2 ] ) # Explorer.DataFrame &lt; Polars [ 6 x 2 ] x integer [ 1 , 2 , 3 , 4 , 5 , ... ] y string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; , &quot;e&quot; , ... ] &gt; iex&gt; df1 = Explorer.DataFrame . new ( x : [ 1 , 2 , 3 ] , y : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; df2 = Explorer.DataFrame . new ( x : [ 4.2 , 5.3 , 6.4 ] , y : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . concat_rows ( [ df1 , df2 ] ) # Explorer.DataFrame &lt; Polars [ 6 x 2 ] x float [ 1.0 , 2.0 , 3.0 , 4.2 , 5.3 , ... ] y string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; , &quot;e&quot; , ... ] &gt;","ref":"Explorer.DataFrame.html#concat_rows/1","title":"Explorer.DataFrame.concat_rows/1","type":"function"},{"doc":"Combine two dataframes row-wise. concat_rows(df1, df2) is equivalent to concat_rows([df1, df2]) .","ref":"Explorer.DataFrame.html#concat_rows/2","title":"Explorer.DataFrame.concat_rows/2","type":"function"},{"doc":"Takes distinct rows by a selection of columns. Examples By default will return unique values of the requested columns: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . distinct ( df , columns : [ &quot;year&quot; , &quot;country&quot; ] ) # Explorer.DataFrame &lt; Polars [ 1094 x 2 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] &gt; If keep_all? is set to true , then the first value of each column not in the requested columns will be returned: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . distinct ( df , columns : [ &quot;year&quot; , &quot;country&quot; ] , keep_all? : true ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; A callback on the dataframe's names can be passed instead of a list (like select/3 ): iex&gt; df = Explorer.DataFrame . new ( x1 : [ 1 , 3 , 3 ] , x2 : [ &quot;a&quot; , &quot;c&quot; , &quot;c&quot; ] , y1 : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . distinct ( df , columns : &amp; String . starts_with? ( &amp;1 , &quot;x&quot; ) ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] x1 integer [ 1 , 3 ] x2 string [ &quot;a&quot; , &quot;c&quot; ] &gt;","ref":"Explorer.DataFrame.html#distinct/2","title":"Explorer.DataFrame.distinct/2","type":"function"},{"doc":"Drop nil values. Optionally accepts a subset of columns. Examples iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , nil ] , b : [ 1 , nil , 3 ] ) iex&gt; Explorer.DataFrame . drop_nil ( df ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] a integer [ 1 ] b integer [ 1 ] &gt; iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , nil ] , b : [ 1 , nil , 3 ] , c : [ nil , 5 , 6 ] ) iex&gt; Explorer.DataFrame . drop_nil ( df , [ :a , :c ] ) # Explorer.DataFrame &lt; Polars [ 1 x 3 ] a integer [ 2 ] b integer [ nil ] c integer [ 5 ] &gt; iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , nil ] , b : [ 1 , nil , 3 ] , c : [ nil , 5 , 6 ] ) iex&gt; Explorer.DataFrame . drop_nil ( df , 0 .. 1 ) # Explorer.DataFrame &lt; Polars [ 1 x 3 ] a integer [ 1 ] b integer [ 1 ] c integer [ nil ] &gt;","ref":"Explorer.DataFrame.html#drop_nil/2","title":"Explorer.DataFrame.drop_nil/2","type":"function"},{"doc":"Gets the dtypes of the dataframe columns. Examples iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , 2 ] ) iex&gt; Explorer.DataFrame . dtypes ( df ) [ :float , :integer ]","ref":"Explorer.DataFrame.html#dtypes/1","title":"Explorer.DataFrame.dtypes/1","type":"function"},{"doc":"Turns a set of columns to dummy variables. Examples iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; , &quot;c&quot; ] , b : [ &quot;b&quot; , &quot;a&quot; , &quot;b&quot; , &quot;d&quot; ] ) iex&gt; Explorer.DataFrame . dummies ( df , [ &quot;a&quot; ] ) # Explorer.DataFrame &lt; Polars [ 4 x 3 ] a_a integer [ 1 , 0 , 1 , 0 ] a_b integer [ 0 , 1 , 0 , 0 ] a_c integer [ 0 , 0 , 0 , 1 ] &gt; iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; , &quot;c&quot; ] , b : [ &quot;b&quot; , &quot;a&quot; , &quot;b&quot; , &quot;d&quot; ] ) iex&gt; Explorer.DataFrame . dummies ( df , [ &quot;a&quot; , &quot;b&quot; ] ) # Explorer.DataFrame &lt; Polars [ 4 x 6 ] a_a integer [ 1 , 0 , 1 , 0 ] a_b integer [ 0 , 1 , 0 , 0 ] a_c integer [ 0 , 0 , 0 , 1 ] b_a integer [ 0 , 1 , 0 , 0 ] b_b integer [ 1 , 0 , 1 , 0 ] b_d integer [ 0 , 0 , 0 , 1 ] &gt;","ref":"Explorer.DataFrame.html#dummies/2","title":"Explorer.DataFrame.dummies/2","type":"function"},{"doc":"Writes a dataframe to a binary representation of a delimited file. Options header - Should the column names be written as the first line of the file? (default: true ) delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df |&gt; Explorer.DataFrame . head ( 2 ) |&gt; Explorer.DataFrame . dump_csv ( ) &quot;year,country,total,solid_fuel,liquid_fuel,gas_fuel,cement,gas_flaring,per_capita,bunker_fuels \\n 2010,AFGHANISTAN,2308,627,1601,74,5,0,0.08,9 \\n 2010,ALBANIA,1254,117,953,7,177,0,0.43,7 \\n &quot;","ref":"Explorer.DataFrame.html#dump_csv/2","title":"Explorer.DataFrame.dump_csv/2","type":"function"},{"doc":"Subset rows using column values. Examples You can pass a mask directly: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter ( df , Explorer.Series . greater ( df [ &quot;b&quot; ] , 1 ) ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] a string [ &quot;b&quot; , &quot;c&quot; ] b integer [ 2 , 3 ] &gt; You can combine masks using Explorer.Series.and/2 or Explorer.Series.or/2 : iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; b_gt = Explorer.Series . greater ( df [ &quot;b&quot; ] , 1 ) iex&gt; a_eq = Explorer.Series . equal ( df [ &quot;a&quot; ] , &quot;b&quot; ) iex&gt; Explorer.DataFrame . filter ( df , Explorer.Series . and ( a_eq , b_gt ) ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] a string [ &quot;b&quot; ] b integer [ 2 ] &gt; Including a list: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter ( df , [ false , true , false ] ) # Explorer.DataFrame &lt; Polars [ 1 x 2 ] a string [ &quot;b&quot; ] b integer [ 2 ] &gt; Or you can invoke a callback on the dataframe: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . filter ( df , &amp; Explorer.Series . greater ( &amp;1 [ &quot;b&quot; ] , 1 ) ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] a string [ &quot;b&quot; , &quot;c&quot; ] b integer [ 2 , 3 ] &gt;","ref":"Explorer.DataFrame.html#filter/2","title":"Explorer.DataFrame.filter/2","type":"function"},{"doc":"Similar to from_csv/2 but raises if there is a problem reading the CSV.","ref":"Explorer.DataFrame.html#from_csv!/2","title":"Explorer.DataFrame.from_csv!/2","type":"function"},{"doc":"Reads a delimited file into a dataframe. If the CSV is compressed, it is automatically decompressed. Options delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) dtypes - A list/map of {&quot;column_name&quot;, dtype} tuples. Any non-specified column has its type imputed from the first 1000 rows. (default: [] ) header - Does the file have a header of column names as the first row or not? (default: true ) max_rows - Maximum number of lines to read. (default: nil ) null_character - The string that should be interpreted as a nil value. (default: &quot;NA&quot; ) skip_rows - The number of lines to skip at the beginning of the file. (default: 0 ) columns - A list of column names or indexes to keep. If present, only these columns are read into the dataframe. (default: nil ) infer_schema_length Maximum number of rows read for schema inference. Setting this to nil will do a full table scan and will be slow (default: 1000 ). parse_dates - Automatically try to parse dates/ datetimes and time. If parsing fails, columns remain of dtype string","ref":"Explorer.DataFrame.html#from_csv/2","title":"Explorer.DataFrame.from_csv/2","type":"function"},{"doc":"Similar to from_ipc/2 but raises if there is a problem reading the IPC file.","ref":"Explorer.DataFrame.html#from_ipc!/2","title":"Explorer.DataFrame.from_ipc!/2","type":"function"},{"doc":"Reads an IPC file into a dataframe. Options columns - List with the name or index of columns to be selected. Defaults to all columns.","ref":"Explorer.DataFrame.html#from_ipc/2","title":"Explorer.DataFrame.from_ipc/2","type":"function"},{"doc":"Read a file of JSON objects or lists separated by new lines Options batch_size - Sets the batch size for reading rows. This value may have significant impact in performance, so adjust it for your needs (default: 1000 ). infer_schema_length - Maximum number of rows read for schema inference. Setting this to nil will do a full table scan and will be slow (default: 1000 ).","ref":"Explorer.DataFrame.html#from_ndjson/2","title":"Explorer.DataFrame.from_ndjson/2","type":"function"},{"doc":"Reads a parquet file into a dataframe.","ref":"Explorer.DataFrame.html#from_parquet/2","title":"Explorer.DataFrame.from_parquet/2","type":"function"},{"doc":"Group the dataframe by one or more variables. When the dataframe has grouping variables, operations are performed per group. Explorer.DataFrame.ungroup/2 removes grouping. Examples You can group by a single variable: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . group_by ( df , &quot;country&quot; ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] Groups : [ &quot;country&quot; ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; Or you can group by multiple: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . group_by ( df , [ &quot;country&quot; , &quot;year&quot; ] ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] Groups : [ &quot;country&quot; , &quot;year&quot; ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt;","ref":"Explorer.DataFrame.html#group_by/2","title":"Explorer.DataFrame.group_by/2","type":"function"},{"doc":"Returns the groups of a dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df = Explorer.DataFrame . group_by ( df , &quot;country&quot; ) iex&gt; Explorer.DataFrame . groups ( df ) [ &quot;country&quot; ]","ref":"Explorer.DataFrame.html#groups/1","title":"Explorer.DataFrame.groups/1","type":"function"},{"doc":"Returns the first n rows of the dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . head ( df ) # Explorer.DataFrame &lt; Polars [ 5 x 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 ] cement integer [ 5 , 177 , 2598 , 0 , 204 ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 ] &gt;","ref":"Explorer.DataFrame.html#head/2","title":"Explorer.DataFrame.head/2","type":"function"},{"doc":"Join two tables. Join types inner - Returns all rows from left where there are matching values in right , and all columns from left and right . left - Returns all rows from left and all columns from left and right . Rows in left with no match in right will have nil values in the new columns. right - Returns all rows from right and all columns from left and right . Rows in right with no match in left will have nil values in the new columns. outer - Returns all rows and all columns from both left and right . Where there are not matching values, returns nil for the one missing. cross - Also known as a cartesian join. Returns all combinations of left and right . Can be very computationally expensive. Options on - The columns to join on. Defaults to overlapping columns. Does not apply to cross join. how - One of the join types (as an atom) described above. Defaults to :inner . Examples Inner join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 2 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a integer [ 1 , 2 , 2 ] b string [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] &gt; Left join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 2 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , how : :left ) # Explorer.DataFrame &lt; Polars [ 4 x 3 ] a integer [ 1 , 2 , 2 , 3 ] b string [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; , &quot;c&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , nil ] &gt; Right join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , how : :right ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a integer [ 1 , 2 , 4 ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] b string [ &quot;a&quot; , &quot;b&quot; , nil ] &gt; Outer join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , how : :outer ) # Explorer.DataFrame &lt; Polars [ 4 x 3 ] a integer [ 1 , 2 , 4 , 3 ] b string [ &quot;a&quot; , &quot;b&quot; , nil , &quot;c&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , nil ] &gt; Cross join: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , how : :cross ) # Explorer.DataFrame &lt; Polars [ 9 x 4 ] a integer [ 1 , 1 , 1 , 2 , 2 , ... ] b string [ &quot;a&quot; , &quot;a&quot; , &quot;a&quot; , &quot;b&quot; , &quot;b&quot; , ... ] a_right integer [ 1 , 2 , 4 , 1 , 2 , ... ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , &quot;d&quot; , &quot;e&quot; , ... ] &gt; Inner join with different names: iex&gt; left = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; right = Explorer.DataFrame . new ( d : [ 1 , 2 , 2 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] ) iex&gt; Explorer.DataFrame . join ( left , right , on : [ { &quot;a&quot; , &quot;d&quot; } ] ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a integer [ 1 , 2 , 2 ] b string [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] &gt;","ref":"Explorer.DataFrame.html#join/3","title":"Explorer.DataFrame.join/3","type":"function"},{"doc":"Creates and modifies columns. Columns are added with keyword list or maps. New variables overwrite existing variables of the same name. Column names are coerced from atoms to strings. Examples You can pass in a list directly as a new column: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , c : [ 4 , 5 , 6 ] ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c integer [ 4 , 5 , 6 ] &gt; Or you can pass in a series: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; s = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.DataFrame . mutate ( df , c : s ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c integer [ 4 , 5 , 6 ] &gt; Or you can invoke a callback on the dataframe: iex&gt; df = Explorer.DataFrame . new ( a : [ 4 , 5 , 6 ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , c : &amp; Explorer.Series . add ( &amp;1 [ &quot;a&quot; ] , &amp;1 [ &quot;b&quot; ] ) ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a integer [ 4 , 5 , 6 ] b integer [ 1 , 2 , 3 ] c integer [ 5 , 7 , 9 ] &gt; You can overwrite existing columns: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , a : [ 4 , 5 , 6 ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a integer [ 4 , 5 , 6 ] b integer [ 1 , 2 , 3 ] &gt; Scalar values are repeated to fill the series: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , a : 4 ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a integer [ 4 , 4 , 4 ] b integer [ 1 , 2 , 3 ] &gt; Including when a callback returns a scalar: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , a : &amp; Explorer.Series . max ( &amp;1 [ &quot;b&quot; ] ) ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a integer [ 3 , 3 , 3 ] b integer [ 1 , 2 , 3 ] &gt; Alternatively, all of the above works with a map instead of a keyword list: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . mutate ( df , %{ &quot;c&quot; =&gt; [ 4 , 5 , 6 ] } ) # Explorer.DataFrame &lt; Polars [ 3 x 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c integer [ 4 , 5 , 6 ] &gt;","ref":"Explorer.DataFrame.html#mutate/2","title":"Explorer.DataFrame.mutate/2","type":"function"},{"doc":"Returns the number of columns in the dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . n_columns ( df ) 10","ref":"Explorer.DataFrame.html#n_columns/1","title":"Explorer.DataFrame.n_columns/1","type":"function"},{"doc":"Returns the number of rows in the dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . n_rows ( df ) 1094","ref":"Explorer.DataFrame.html#n_rows/1","title":"Explorer.DataFrame.n_rows/1","type":"function"},{"doc":"Gets the names of the dataframe columns. Examples iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , 2 ] ) iex&gt; Explorer.DataFrame . names ( df ) [ &quot;floats&quot; , &quot;ints&quot; ]","ref":"Explorer.DataFrame.html#names/1","title":"Explorer.DataFrame.names/1","type":"function"},{"doc":"Creates a new dataframe. Accepts any tabular data adhering to the Table.Reader protocol, as well as a map or a keyword list with series. Options backend - The Explorer backend to use. Defaults to the value returned by Explorer.Backend.get/0 . Examples From series: iex&gt; Explorer.DataFrame . new ( %{ floats : Explorer.Series . from_list ( [ 1.0 , 2.0 ] ) , ints : Explorer.Series . from_list ( [ 1 , nil ] ) } ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] floats float [ 1.0 , 2.0 ] ints integer [ 1 , nil ] &gt; From columnar data: iex&gt; Explorer.DataFrame . new ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] } ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] floats float [ 1.0 , 2.0 ] ints integer [ 1 , nil ] &gt; iex&gt; Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] floats float [ 1.0 , 2.0 ] ints integer [ 1 , nil ] &gt; iex&gt; Explorer.DataFrame . new ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , &quot;wrong&quot; ] } ) ** (ArgumentError) cannot create series &quot;ints&quot;: the value &quot;wrong&quot; does not match the inferred series dtype :integer From row data: iex&gt; rows = [ %{ id : 1 , name : &quot;José&quot; } , %{ id : 2 , name : &quot;Christopher&quot; } , %{ id : 3 , name : &quot;Cristine&quot; } ] iex&gt; Explorer.DataFrame . new ( rows ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] id integer [ 1 , 2 , 3 ] name string [ &quot;José&quot; , &quot;Christopher&quot; , &quot;Cristine&quot; ] &gt; iex&gt; rows = [ [ id : 1 , name : &quot;José&quot; ] , [ id : 2 , name : &quot;Christopher&quot; ] , [ id : 3 , name : &quot;Cristine&quot; ] ] iex&gt; Explorer.DataFrame . new ( rows ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] id integer [ 1 , 2 , 3 ] name string [ &quot;José&quot; , &quot;Christopher&quot; , &quot;Cristine&quot; ] &gt;","ref":"Explorer.DataFrame.html#new/2","title":"Explorer.DataFrame.new/2","type":"function"},{"doc":"Pivot data from wide to long. Explorer.DataFrame.pivot_longer/3 &quot;lengthens&quot; data, increasing the number of rows and decreasing the number of columns. The inverse transformation is Explorer.DataFrame.pivot_wider/4 . The second argument ( columns ) can be either an array of column names to use or a filter callback on the dataframe's names. value_columns must all have the same dtype. Options value_columns - Columns to use for values. May be a filter callback on the dataframe's column names. Defaults to an empty list, using all variables except the columns to pivot. names_to - A string specifying the name of the column to create from the data stored in the column names of the dataframe. Defaults to &quot;variable&quot; . values_to - A string specifying the name of the column to create from the data stored in series element values. Defaults to &quot;value&quot; . Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pivot_longer ( df , [ &quot;year&quot; , &quot;country&quot; ] , value_columns : &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) ) # Explorer.DataFrame &lt; Polars [ 3282 x 4 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] variable string [ &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , ... ] value integer [ 627 , 117 , 332 , 0 , 0 , ... ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pivot_longer ( df , [ &quot;year&quot; , &quot;country&quot; ] , value_columns : [ &quot;total&quot; ] ) # Explorer.DataFrame &lt; Polars [ 1094 x 4 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] variable string [ &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , ... ] value integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] &gt;","ref":"Explorer.DataFrame.html#pivot_longer/3","title":"Explorer.DataFrame.pivot_longer/3","type":"function"},{"doc":"Pivot data from long to wide. Explorer.DataFrame.pivot_wider/4 &quot;widens&quot; data, increasing the number of columns and decreasing the number of rows. The inverse transformation is Explorer.DataFrame.pivot_longer/3 . Due to a restriction upstream, values_from must be a numeric type. Options id_columns - A set of columns that uniquely identifies each observation. Defaults to all columns in data except for the columns specified in names_from and values_from . Typically used when you have redundant variables, i.e. variables whose values are perfectly correlated with existing variables. May accept a filter callback, a list or a range of column names. Default value is 0..-1 . If an empty list is passed, or a range that results in a empty list of column names, it raises an error. names_prefix - String added to the start of every variable name. This is particularly useful if names_from is a numeric vector and you want to create syntactic variable names. Examples iex&gt; df = Explorer.DataFrame . new ( id : [ 1 , 1 ] , variable : [ &quot;a&quot; , &quot;b&quot; ] , value : [ 1 , 2 ] ) iex&gt; Explorer.DataFrame . pivot_wider ( df , &quot;variable&quot; , &quot;value&quot; ) # Explorer.DataFrame &lt; Polars [ 1 x 3 ] id integer [ 1 ] a integer [ 1 ] b integer [ 2 ] &gt;","ref":"Explorer.DataFrame.html#pivot_wider/4","title":"Explorer.DataFrame.pivot_wider/4","type":"function"},{"doc":"Extracts a single column as a series. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pull ( df , &quot;total&quot; ) # Explorer.Series &lt; integer [ 1094 ] [ 2308 , 1254 , 32500 , 141 , 7924 , 41 , 143 , 51246 , 1150 , 684 , 106589 , 18408 , 8366 , 451 , 7981 , 16345 , 403 , 17192 , 30222 , 147 , 1388 , 166 , 133 , 5802 , 1278 , 114468 , 47 , 2237 , 12030 , 535 , 58 , 1367 , 145806 , 152 , 152 , 72 , 141 , 19703 , 2393248 , 20773 , 44 , 540 , 19 , 2064 , 1900 , 5501 , 10465 , 2102 , 30428 , 18122 , ... ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pull ( df , 2 ) # Explorer.Series &lt; integer [ 1094 ] [ 2308 , 1254 , 32500 , 141 , 7924 , 41 , 143 , 51246 , 1150 , 684 , 106589 , 18408 , 8366 , 451 , 7981 , 16345 , 403 , 17192 , 30222 , 147 , 1388 , 166 , 133 , 5802 , 1278 , 114468 , 47 , 2237 , 12030 , 535 , 58 , 1367 , 145806 , 152 , 152 , 72 , 141 , 19703 , 2393248 , 20773 , 44 , 540 , 19 , 2064 , 1900 , 5501 , 10465 , 2102 , 30428 , 18122 , ... ] &gt;","ref":"Explorer.DataFrame.html#pull/2","title":"Explorer.DataFrame.pull/2","type":"function"},{"doc":"Renames columns. To apply a function to a subset of columns, see rename_with/3 . Examples You can pass in a list of new names: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] ) iex&gt; Explorer.DataFrame . rename ( df , [ &quot;c&quot; , &quot;d&quot; ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] c string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] d integer [ 1 , 3 , 1 ] &gt; Or you can rename individual columns using keyword args: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] ) iex&gt; Explorer.DataFrame . rename ( df , a : &quot;first&quot; ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] first string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 1 , 3 , 1 ] &gt; Or you can rename individual columns using a map: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] ) iex&gt; Explorer.DataFrame . rename ( df , %{ &quot;a&quot; =&gt; &quot;first&quot; } ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] first string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 1 , 3 , 1 ] &gt;","ref":"Explorer.DataFrame.html#rename/2","title":"Explorer.DataFrame.rename/2","type":"function"},{"doc":"Renames columns with a function. Examples If no columns are specified, it will apply the function to all column names: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , &amp; String . upcase / 1 ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] YEAR integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] COUNTRY string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] TOTAL integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] SOLID_FUEL integer [ 627 , 117 , 332 , 0 , 0 , ... ] LIQUID_FUEL integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] GAS_FUEL integer [ 74 , 7 , 14565 , 0 , 374 , ... ] CEMENT integer [ 5 , 177 , 2598 , 0 , 204 , ... ] GAS_FLARING integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] PER_CAPITA float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] BUNKER_FUELS integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; A callback can be used to filter the column names that will be renamed, similarly to select/3 : iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , &amp; String . ends_with? ( &amp;1 , &quot;_fuel&quot; ) , &amp; String . trim_trailing ( &amp;1 , &quot;_fuel&quot; ) ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt; Or you can just pass in the list of column names you'd like to apply the function to: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , [ &quot;total&quot; , &quot;cement&quot; ] , &amp; String . upcase / 1 ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] TOTAL integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] CEMENT integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt;","ref":"Explorer.DataFrame.html#rename_with/3","title":"Explorer.DataFrame.rename_with/3","type":"function"},{"doc":"Sample rows from a dataframe. If given an integer as the second argument, it will return N samples. If given a float, it will return that proportion of the series. Can sample with or without replacement. Options replacement - If set to true , each sample will be independent and therefore values may repeat. Required to be true for n greater then the number of rows in the dataframe or frac &gt; 1.0. (default: false ) seed - An integer to be used as a random seed. If nil, a random value between 1 and 1e12 will be used. (default: nil) Examples You can sample N rows: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . sample ( df , 3 , seed : 100 ) # Explorer.DataFrame &lt; Polars [ 3 x 10 ] year integer [ 2012 , 2012 , 2013 ] country string [ &quot;ZIMBABWE&quot; , &quot;NICARAGUA&quot; , &quot;NIGER&quot; ] total integer [ 2125 , 1260 , 529 ] solid_fuel integer [ 917 , 0 , 93 ] liquid_fuel integer [ 1006 , 1176 , 432 ] gas_fuel integer [ 0 , 0 , 0 ] cement integer [ 201 , 84 , 4 ] gas_flaring integer [ 0 , 0 , 0 ] per_capita float [ 0.15 , 0.21 , 0.03 ] bunker_fuels integer [ 9 , 18 , 19 ] &gt; Or you can sample a proportion of rows: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . sample ( df , 0.03 , seed : 100 ) # Explorer.DataFrame &lt; Polars [ 33 x 10 ] year integer [ 2013 , 2012 , 2013 , 2012 , 2010 , ... ] country string [ &quot;BAHAMAS&quot; , &quot;POLAND&quot; , &quot;SLOVAKIA&quot; , &quot;MOZAMBIQUE&quot; , &quot;OMAN&quot; , ... ] total integer [ 764 , 81792 , 9024 , 851 , 12931 , ... ] solid_fuel integer [ 1 , 53724 , 3657 , 11 , 0 , ... ] liquid_fuel integer [ 763 , 17353 , 2090 , 632 , 2331 , ... ] gas_fuel integer [ 0 , 8544 , 2847 , 47 , 9309 , ... ] cement integer [ 0 , 2165 , 424 , 161 , 612 , ... ] gas_flaring integer [ 0 , 6 , 7 , 0 , 679 , ... ] per_capita float [ 2.02 , 2.12 , 1.67 , 0.03 , 4.39 , ... ] bunker_fuels integer [ 167 , 573 , 34 , 56 , 1342 , ... ] &gt;","ref":"Explorer.DataFrame.html#sample/3","title":"Explorer.DataFrame.sample/3","type":"function"},{"doc":"Selects a subset of columns by name. Can optionally return all but the named columns if :drop is passed as the last argument. Examples You can select columns with a list of names: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . select ( df , [ &quot;a&quot; ] ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] &gt; You can also use a range or a list of integers: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] , c : [ 4 , 5 , 6 ] ) iex&gt; Explorer.DataFrame . select ( df , [ 0 , 1 ] ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] &gt; iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] , c : [ 4 , 5 , 6 ] ) iex&gt; Explorer.DataFrame . select ( df , 0 .. 1 ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] &gt; Or you can use a callback function that takes the dataframe's names as its first argument: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . select ( df , &amp; String . starts_with? ( &amp;1 , &quot;b&quot; ) ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] b integer [ 1 , 2 , 3 ] &gt; If you pass :drop as the third argument, it will return all but the named columns: iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . select ( df , [ &quot;b&quot; ] , :drop ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] &gt; iex&gt; df = Explorer.DataFrame . new ( a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] , c : [ 4 , 5 , 6 ] ) iex&gt; Explorer.DataFrame . select ( df , [ &quot;a&quot; , &quot;b&quot; ] , :drop ) # Explorer.DataFrame &lt; Polars [ 3 x 1 ] c integer [ 4 , 5 , 6 ] &gt;","ref":"Explorer.DataFrame.html#select/3","title":"Explorer.DataFrame.select/3","type":"function"},{"doc":"Gets the shape of the dataframe as a {height, width} tuple. Examples iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 , 3.0 ] , ints : [ 1 , 2 , 3 ] ) iex&gt; Explorer.DataFrame . shape ( df ) { 3 , 2 }","ref":"Explorer.DataFrame.html#shape/1","title":"Explorer.DataFrame.shape/1","type":"function"},{"doc":"Subset a continuous set of rows. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . slice ( df , 1 , 2 ) # Explorer.DataFrame &lt; Polars [ 2 x 10 ] year integer [ 2010 , 2010 ] country string [ &quot;ALBANIA&quot; , &quot;ALGERIA&quot; ] total integer [ 1254 , 32500 ] solid_fuel integer [ 117 , 332 ] liquid_fuel integer [ 953 , 12381 ] gas_fuel integer [ 7 , 14565 ] cement integer [ 177 , 2598 ] gas_flaring integer [ 0 , 2623 ] per_capita float [ 0.43 , 0.9 ] bunker_fuels integer [ 7 , 663 ] &gt; Negative offsets count from the end of the series: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . slice ( df , - 10 , 2 ) # Explorer.DataFrame &lt; Polars [ 2 x 10 ] year integer [ 2014 , 2014 ] country string [ &quot;UNITED STATES OF AMERICA&quot; , &quot;URUGUAY&quot; ] total integer [ 1432855 , 1840 ] solid_fuel integer [ 450047 , 2 ] liquid_fuel integer [ 576531 , 1700 ] gas_fuel integer [ 390719 , 25 ] cement integer [ 11314 , 112 ] gas_flaring integer [ 4244 , 0 ] per_capita float [ 4.43 , 0.54 ] bunker_fuels integer [ 30722 , 251 ] &gt; If the length would run past the end of the dataframe, the result may be shorter than the length: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . slice ( df , - 10 , 20 ) # Explorer.DataFrame &lt; Polars [ 10 x 10 ] year integer [ 2014 , 2014 , 2014 , 2014 , 2014 , ... ] country string [ &quot;UNITED STATES OF AMERICA&quot; , &quot;URUGUAY&quot; , &quot;UZBEKISTAN&quot; , &quot;VANUATU&quot; , &quot;VENEZUELA&quot; , ... ] total integer [ 1432855 , 1840 , 28692 , 42 , 50510 , ... ] solid_fuel integer [ 450047 , 2 , 1677 , 0 , 204 , ... ] liquid_fuel integer [ 576531 , 1700 , 2086 , 42 , 28445 , ... ] gas_fuel integer [ 390719 , 25 , 23929 , 0 , 12731 , ... ] cement integer [ 11314 , 112 , 1000 , 0 , 1088 , ... ] gas_flaring integer [ 4244 , 0 , 0 , 0 , 8042 , ... ] per_capita float [ 4.43 , 0.54 , 0.97 , 0.16 , 1.65 , ... ] bunker_fuels integer [ 30722 , 251 , 0 , 10 , 1256 , ... ] &gt;","ref":"Explorer.DataFrame.html#slice/3","title":"Explorer.DataFrame.slice/3","type":"function"},{"doc":"Summarise each group to a single row. Implicitly ungroups. Supported operations The following aggregations may be performed: :min - Take the minimum value within the group. See Explorer.Series.min/1 . :max - Take the maximum value within the group. See Explorer.Series.max/1 . :sum - Take the sum of the series within the group. See Explorer.Series.sum/1 . :mean - Take the mean of the series within the group. See Explorer.Series.mean/1 . :median - Take the median of the series within the group. See Explorer.Series.median/1 . :first - Take the first value within the group. See Explorer.Series.first/1 . :last - Take the last value within the group. See Explorer.Series.last/1 . :count - Count the number of rows per group. :n_unique - Count the number of unique rows per group. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df |&gt; Explorer.DataFrame . group_by ( &quot;year&quot; ) |&gt; Explorer.DataFrame . summarise ( total : [ :max , :min ] , country : [ :n_unique ] ) # Explorer.DataFrame &lt; Polars [ 5 x 4 ] year integer [ 2010 , 2011 , 2012 , 2013 , 2014 ] country_n_unique integer [ 217 , 217 , 220 , 220 , 220 ] total_max integer [ 2393248 , 2654360 , 2734817 , 2797384 , 2806634 ] total_min integer [ 1 , 2 , 2 , 2 , 3 ] &gt;","ref":"Explorer.DataFrame.html#summarise/2","title":"Explorer.DataFrame.summarise/2","type":"function"},{"doc":"Display the DataFrame in a tabular fashion. Examples df = Explorer.Datasets.iris() Explorer.DataFrame.table(df)","ref":"Explorer.DataFrame.html#table/2","title":"Explorer.DataFrame.table/2","type":"function"},{"doc":"Returns the last n rows of the dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . tail ( df ) # Explorer.DataFrame &lt; Polars [ 5 x 10 ] year integer [ 2014 , 2014 , 2014 , 2014 , 2014 ] country string [ &quot;VIET NAM&quot; , &quot;WALLIS AND FUTUNA ISLANDS&quot; , &quot;YEMEN&quot; , &quot;ZAMBIA&quot; , &quot;ZIMBABWE&quot; ] total integer [ 45517 , 6 , 6190 , 1228 , 3278 ] solid_fuel integer [ 19246 , 0 , 137 , 132 , 2097 ] liquid_fuel integer [ 12694 , 6 , 5090 , 797 , 1005 ] gas_fuel integer [ 5349 , 0 , 581 , 0 , 0 ] cement integer [ 8229 , 0 , 381 , 299 , 177 ] gas_flaring integer [ 0 , 0 , 0 , 0 , 0 ] per_capita float [ 0.49 , 0.44 , 0.24 , 0.08 , 0.22 ] bunker_fuels integer [ 761 , 1 , 153 , 33 , 9 ] &gt;","ref":"Explorer.DataFrame.html#tail/2","title":"Explorer.DataFrame.tail/2","type":"function"},{"doc":"Subset rows with a list of indices. Examples iex&gt; df = Explorer.DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.DataFrame . take ( df , [ 0 , 2 ] ) # Explorer.DataFrame &lt; Polars [ 2 x 2 ] a integer [ 1 , 3 ] b string [ &quot;a&quot; , &quot;c&quot; ] &gt;","ref":"Explorer.DataFrame.html#take/2","title":"Explorer.DataFrame.take/2","type":"function"},{"doc":"Converts a dataframe to a list of columns with lists as values. See to_series/2 if you want a list of columns with series as values. Options :atom_keys - Configure if the resultant map should have atom keys. (default: false ) Examples iex&gt; df = Explorer.DataFrame . new ( ints : [ 1 , nil ] , floats : [ 1.0 , 2.0 ] ) iex&gt; Explorer.DataFrame . to_columns ( df ) %{ &quot;floats&quot; =&gt; [ 1.0 , 2.0 ] , &quot;ints&quot; =&gt; [ 1 , nil ] } iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] ) iex&gt; Explorer.DataFrame . to_columns ( df , atom_keys : true ) %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] }","ref":"Explorer.DataFrame.html#to_columns/2","title":"Explorer.DataFrame.to_columns/2","type":"function"},{"doc":"Similar to to_csv/3 but raises if there is a problem reading the CSV.","ref":"Explorer.DataFrame.html#to_csv!/3","title":"Explorer.DataFrame.to_csv!/3","type":"function"},{"doc":"Writes a dataframe to a delimited file. Options header - Should the column names be written as the first line of the file? (default: true ) delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; )","ref":"Explorer.DataFrame.html#to_csv/3","title":"Explorer.DataFrame.to_csv/3","type":"function"},{"doc":"Writes a dataframe to a IPC file. Apache IPC is a language-agnostic columnar data structure that can be used to store data frames. It excels as a format for quickly exchange data between different programming languages. Options compression - Sets the algorithm used to compress the IPC file. It accepts &quot;ZSTD&quot; or &quot;LZ4&quot; compression. (default: nil )","ref":"Explorer.DataFrame.html#to_ipc/3","title":"Explorer.DataFrame.to_ipc/3","type":"function"},{"doc":"Converts the dataframe to the lazy version of the current backend. If already lazy, this is a noop.","ref":"Explorer.DataFrame.html#to_lazy/1","title":"Explorer.DataFrame.to_lazy/1","type":"function"},{"doc":"Writes a dataframe to a ndjson file.","ref":"Explorer.DataFrame.html#to_ndjson/2","title":"Explorer.DataFrame.to_ndjson/2","type":"function"},{"doc":"Writes a dataframe to a parquet file.","ref":"Explorer.DataFrame.html#to_parquet/2","title":"Explorer.DataFrame.to_parquet/2","type":"function"},{"doc":"Converts a dataframe to a list of maps (rows). Warning This may be an expensive operation because polars stores data in columnar format. Options :atom_keys - Configure if the resultant maps should have atom keys. (default: false ) Examples iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] ) iex&gt; Explorer.DataFrame . to_rows ( df ) [ %{ &quot;floats&quot; =&gt; 1.0 , &quot;ints&quot; =&gt; 1 } , %{ &quot;floats&quot; =&gt; 2.0 , &quot;ints&quot; =&gt; nil } ] iex&gt; df = Explorer.DataFrame . new ( floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] ) iex&gt; Explorer.DataFrame . to_rows ( df , atom_keys : true ) [ %{ floats : 1.0 , ints : 1 } , %{ floats : 2.0 , ints : nil } ]","ref":"Explorer.DataFrame.html#to_rows/2","title":"Explorer.DataFrame.to_rows/2","type":"function"},{"doc":"Converts a dataframe to a list of columns with series as values. See to_columns/2 if you want a list of columns with lists as values. Options :atom_keys - Configure if the resultant map should have atom keys. (default: false ) Examples iex&gt; df = Explorer.DataFrame . new ( ints : [ 1 , nil ] , floats : [ 1.0 , 2.0 ] ) iex&gt; map = Explorer.DataFrame . to_series ( df ) iex&gt; Explorer.Series . to_list ( map [ &quot;floats&quot; ] ) [ 1.0 , 2.0 ] iex&gt; Explorer.Series . to_list ( map [ &quot;ints&quot; ] ) [ 1 , nil ]","ref":"Explorer.DataFrame.html#to_series/2","title":"Explorer.DataFrame.to_series/2","type":"function"},{"doc":"Removes grouping variables. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df = Explorer.DataFrame . group_by ( df , [ &quot;country&quot; , &quot;year&quot; ] ) iex&gt; Explorer.DataFrame . ungroup ( df , [ &quot;country&quot; ] ) # Explorer.DataFrame &lt; Polars [ 1094 x 10 ] Groups : [ &quot;year&quot; ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , ... ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , ... ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , ... ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , ... ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , ... ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , ... ] cement integer [ 5 , 177 , 2598 , 0 , 204 , ... ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , ... ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , ... ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , ... ] &gt;","ref":"Explorer.DataFrame.html#ungroup/2","title":"Explorer.DataFrame.ungroup/2","type":"function"},{"doc":"","ref":"Explorer.DataFrame.html#t:column/0","title":"Explorer.DataFrame.column/0","type":"type"},{"doc":"","ref":"Explorer.DataFrame.html#t:column_name/0","title":"Explorer.DataFrame.column_name/0","type":"type"},{"doc":"","ref":"Explorer.DataFrame.html#t:column_names/0","title":"Explorer.DataFrame.column_names/0","type":"type"},{"doc":"","ref":"Explorer.DataFrame.html#t:column_pairs/1","title":"Explorer.DataFrame.column_pairs/1","type":"type"},{"doc":"","ref":"Explorer.DataFrame.html#t:columns/0","title":"Explorer.DataFrame.columns/0","type":"type"},{"doc":"","ref":"Explorer.DataFrame.html#t:data/0","title":"Explorer.DataFrame.data/0","type":"type"},{"doc":"","ref":"Explorer.DataFrame.html#t:t/0","title":"Explorer.DataFrame.t/0","type":"type"},{"doc":"","ref":"Explorer.Datasets.html","title":"Explorer.Datasets","type":"module"},{"doc":"CO2 emissions from fossil fuels since 2010, by country Citation Boden, T.A., G. Marland, and R.J. Andres. 2013. Global, Regional, and National Fossil-Fuel CO2 Emissions. Carbon Dioxide Information Analysis Center, Oak Ridge National Laboratory, U.S. Department of Energy, Oak Ridge, Tenn., U.S.A. doi 10.3334/CDIAC/00001_V2013","ref":"Explorer.Datasets.html#fossil_fuels/0","title":"Explorer.Datasets.fossil_fuels/0","type":"function"},{"doc":"Iris Dataset - This classic dataset was collected by Edgar Anderson in 1936 and made famous by R. A. Fisher's 1936 paper. It consists of several measurements of three species of Iris (Iris setosa, Iris virginica and Iris versicolor). Downloaded and modified from: https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data Citation Original Owners: R. A. Fisher (1936) The use of multiple measurements in taxonomic problems. Annals of Eugenics. 7 (2): 179–188. doi:10.1111/j.1469-1809.1936.tb02137.x Iris. (1936). UCI Machine Learning Repository.","ref":"Explorer.Datasets.html#iris/0","title":"Explorer.Datasets.iris/0","type":"function"},{"doc":"Wine Dataset - The data is the result of a chemical analysis of wines grown in the same region in Italy but derived from three different cultivars. The analysis determined the quantities of 13 constituents found in each of the three types of wines. Downloaded and modified from: https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data Citation Original Owners: Forina, M. et al, PARVUS - An Extendible Package for Data Exploration, Classification and Correlation. Institute of Pharmaceutical and Food Analysis and Technologies, Via Brigata Salerno, 16147 Genoa, Italy. Wine. (1991). UCI Machine Learning Repository.","ref":"Explorer.Datasets.html#wine/0","title":"Explorer.Datasets.wine/0","type":"function"},{"doc":"The Series struct and API. A series can be of the following data types: :float - 64-bit floating point number :integer - 64-bit signed integer :boolean - Boolean :string - UTF-8 encoded binary :date - Date type that unwraps to Elixir.Date :datetime - DateTime type that unwraps to Elixir.NaiveDateTime A series must consist of a single data type only. Series are nullable, but may not consist only of nils. Many functions only apply to certain dtypes. Where that is the case, you'll find a Supported dtypes section in the function documentation and the function will raise an ArgumentError if a series with an invalid dtype is used.","ref":"Explorer.Series.html","title":"Explorer.Series","type":"module"},{"doc":"Adds right to left, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.Series . add ( s1 , s2 ) # Explorer.Series &lt; integer [ 3 ] [ 5 , 7 , 9 ] &gt;","ref":"Explorer.Series.html#add/2","title":"Explorer.Series.add/2","type":"function"},{"doc":"Checks equality between two entire series. Examples iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; Explorer.Series . all_equal? ( s1 , s2 ) true iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . all_equal? ( s1 , s2 ) false iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 ] ) iex&gt; Explorer.Series . all_equal? ( s1 , s2 ) false","ref":"Explorer.Series.html#all_equal?/2","title":"Explorer.Series.all_equal?/2","type":"function"},{"doc":"Returns a boolean mask of left and right , element-wise Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; mask1 = Explorer.Series . greater ( s1 , 1 ) iex&gt; mask2 = Explorer.Series . less ( s1 , 3 ) iex&gt; Explorer.Series . and ( mask1 , mask2 ) # Explorer.Series &lt; boolean [ 3 ] [ false , true , false ] &gt;","ref":"Explorer.Series.html#and/2","title":"Explorer.Series.and/2","type":"function"},{"doc":"Returns the indices that would sort the series.","ref":"Explorer.Series.html#argsort/2","title":"Explorer.Series.argsort/2","type":"function"},{"doc":"Cast the series to another type. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :string ) # Explorer.Series &lt; string [ 3 ] [ &quot;1&quot; , &quot;2&quot; , &quot;3&quot; ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :float ) # Explorer.Series &lt; float [ 3 ] [ 1.0 , 2.0 , 3.0 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :date ) # Explorer.Series &lt; date [ 3 ] [ 1970 - 01 - 02 , 1970 - 01 - 03 , 1970 - 01 - 04 ] &gt; Note that datetime is represented as an integer of microseconds since Unix Epoch (1970-01-01 00:00:00). iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :datetime ) # Explorer.Series &lt; datetime [ 3 ] [ 1970 - 01 - 01 00 : 00 : 00.000001 , 1970 - 01 - 01 00 : 00 : 00.000002 , 1970 - 01 - 01 00 : 00 : 00.000003 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1649883642 * 1_000 * 1_000 ] ) iex&gt; Explorer.Series . cast ( s , :datetime ) # Explorer.Series &lt; datetime [ 1 ] [ 2022 - 04 - 13 21 : 00 : 42.000000 ] &gt; cast/2 will return the series as a no-op if you try to cast to the same dtype. iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :integer ) # Explorer.Series &lt; integer [ 3 ] [ 1 , 2 , 3 ] &gt;","ref":"Explorer.Series.html#cast/2","title":"Explorer.Series.cast/2","type":"function"},{"doc":"Finds the first non-missing element at each position. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , nil , nil ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; s3 = Explorer.Series . from_list ( [ nil , nil , 3 , 4 ] ) iex&gt; Explorer.Series . coalesce ( [ s1 , s2 , s3 ] ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 3 , 4 ] &gt;","ref":"Explorer.Series.html#coalesce/1","title":"Explorer.Series.coalesce/1","type":"function"},{"doc":"Finds the first non-missing element at each position. coalesce(s1, s2) is equivalent to coalesce([s1, s2]) .","ref":"Explorer.Series.html#coalesce/2","title":"Explorer.Series.coalesce/2","type":"function"},{"doc":"Concatenate one or more series. The dtypes must match unless all are numeric, in which case all series will be downcast to float. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.Series . concat ( [ s1 , s2 ] ) # Explorer.Series &lt; integer [ 6 ] [ 1 , 2 , 3 , 4 , 5 , 6 ] &gt; iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4.0 , 5.0 , 6.4 ] ) iex&gt; Explorer.Series . concat ( s1 , s2 ) # Explorer.Series &lt; float [ 6 ] [ 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.4 ] &gt;","ref":"Explorer.Series.html#concat/1","title":"Explorer.Series.concat/1","type":"function"},{"doc":"Concatenate one or more series. concat(s1, s2) is equivalent to concat([s1, s2]) .","ref":"Explorer.Series.html#concat/2","title":"Explorer.Series.concat/2","type":"function"},{"doc":"Creates a new dataframe with unique values and the count of each. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;c&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . count ( s ) # Explorer.DataFrame &lt; Polars [ 3 x 2 ] values string [ &quot;c&quot; , &quot;a&quot; , &quot;b&quot; ] counts integer [ 3 , 2 , 1 ] &gt;","ref":"Explorer.Series.html#count/1","title":"Explorer.Series.count/1","type":"function"},{"doc":"Calculates the cumulative maximum of the series. Optionally, can fill in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :date :datetime Examples iex&gt; s = [ 1 , 2 , 3 , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_max ( s ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 3 , 4 ] &gt; iex&gt; s = [ 1 , 2 , nil , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_max ( s ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , nil , 4 ] &gt;","ref":"Explorer.Series.html#cumulative_max/2","title":"Explorer.Series.cumulative_max/2","type":"function"},{"doc":"Calculates the cumulative minimum of the series. Optionally, can fill in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :date :datetime Examples iex&gt; s = [ 1 , 2 , 3 , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_min ( s ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 1 , 1 , 1 ] &gt; iex&gt; s = [ 1 , 2 , nil , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_min ( s ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 1 , nil , 1 ] &gt;","ref":"Explorer.Series.html#cumulative_min/2","title":"Explorer.Series.cumulative_min/2","type":"function"},{"doc":"Calculates the cumulative sum of the series. Optionally, can fill in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :boolean Examples iex&gt; s = [ 1 , 2 , 3 , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_sum ( s ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 3 , 6 , 10 ] &gt; iex&gt; s = [ 1 , 2 , nil , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cumulative_sum ( s ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 3 , nil , 7 ] &gt;","ref":"Explorer.Series.html#cumulative_sum/2","title":"Explorer.Series.cumulative_sum/2","type":"function"},{"doc":"Returns the unique values of the series. Examples iex&gt; s = [ 1 , 1 , 2 , 2 , 3 , 3 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . distinct ( ) # Explorer.Series &lt; integer [ 3 ] [ 1 , 2 , 3 ] &gt;","ref":"Explorer.Series.html#distinct/1","title":"Explorer.Series.distinct/1","type":"function"},{"doc":"Divides left by right, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float Examples iex&gt; s1 = [ 10 , 10 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = [ 2 , 2 , 2 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . divide ( s1 , s2 ) # Explorer.Series &lt; integer [ 3 ] [ 5 , 5 , 5 ] &gt; iex&gt; s1 = [ 10 , 10 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . divide ( s1 , 2 ) # Explorer.Series &lt; integer [ 3 ] [ 5 , 5 , 5 ] &gt;","ref":"Explorer.Series.html#divide/2","title":"Explorer.Series.divide/2","type":"function"},{"doc":"Returns the data type of the series. A series can be of the following data types: :float - 64-bit floating point number :integer - 64-bit signed integer :boolean - Boolean :string - UTF-8 encoded binary :date - Date type that unwraps to Elixir.Date :datetime - DateTime type that unwraps to Elixir.NaiveDateTime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . dtype ( s ) :integer iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , nil , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . dtype ( s ) :string","ref":"Explorer.Series.html#dtype/1","title":"Explorer.Series.dtype/1","type":"function"},{"doc":"Returns boolean mask of left == right , element-wise. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . equal ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ true , true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . equal ( s , 1 ) # Explorer.Series &lt; boolean [ 3 ] [ true , false , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ true , true , false ] ) iex&gt; Explorer.Series . equal ( s , true ) # Explorer.Series &lt; boolean [ 3 ] [ true , true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . equal ( s , &quot;a&quot; ) # Explorer.Series &lt; boolean [ 3 ] [ true , false , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . equal ( s , ~D[1999-12-31] ) # Explorer.Series &lt; boolean [ 2 ] [ false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~N[2022-01-01 00:00:00] , ~N[2022-01-01 23:00:00] ] ) iex&gt; Explorer.Series . equal ( s , ~N[2022-01-01 00:00:00] ) # Explorer.Series &lt; boolean [ 2 ] [ true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . equal ( s , false ) ** (ArgumentError) cannot invoke Explorer.Series.equal/2 with mismatched dtypes: string and false.","ref":"Explorer.Series.html#equal/2","title":"Explorer.Series.equal/2","type":"function"},{"doc":"Fill missing values with the given strategy. If a scalar value is provided instead of a strategy atom, nil will be replaced with that value. It must be of the same dtype as the series. Strategies :forward - replace nil with the previous value :backward - replace nil with the next value :max - replace nil with the series maximum :min - replace nil with the series minimum :mean - replace nil with the series mean Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :forward ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 2 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :backward ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 4 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :max ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 4 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :min ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 1 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :mean ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 2 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , 3 ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 3 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 4.0 ] ) iex&gt; Explorer.Series . fill_missing ( s , 3.0 ) # Explorer.Series &lt; float [ 4 ] [ 1.0 , 2.0 , 3.0 , 4.0 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , nil , &quot;d&quot; ] ) iex&gt; Explorer.Series . fill_missing ( s , &quot;c&quot; ) # Explorer.Series &lt; string [ 4 ] [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; ] &gt;","ref":"Explorer.Series.html#fill_missing/2","title":"Explorer.Series.fill_missing/2","type":"function"},{"doc":"Filters a series with a mask or callback. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . filter ( s1 , s2 ) # Explorer.Series &lt; integer [ 2 ] [ 1 , 3 ] &gt; iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 1 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 ] ) iex&gt; Explorer.Series . filter ( s1 , &amp; Explorer.Series . equal ( &amp;1 , s2 ) ) # Explorer.Series &lt; integer [ 2 ] [ 1 , 1 ] &gt;","ref":"Explorer.Series.html#filter/2","title":"Explorer.Series.filter/2","type":"function"},{"doc":"Returns the first element of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . first ( s ) 1","ref":"Explorer.Series.html#first/1","title":"Explorer.Series.first/1","type":"function"},{"doc":"Creates a new series from a list. The list must consist of a single data type and nils. It is possible to have a list of only nil values. In this case, the list will have the :dtype of float. Options :backend - The backend to allocate the series on. :dtype - Cast the series to a given :dtype . By default this is nil , which means that Explorer will infer the type from the values in the list. Examples Explorer will infer the type from the values in the list. iex&gt; Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) # Explorer.Series &lt; integer [ 3 ] [ 1 , 2 , 3 ] &gt; Series are nullable, so you may also include nils. iex&gt; Explorer.Series . from_list ( [ 1.0 , nil , 2.5 , 3.1 ] ) # Explorer.Series &lt; float [ 4 ] [ 1.0 , nil , 2.5 , 3.1 ] &gt; A mix of integers and floats will be downcasted to a float. iex&gt; Explorer.Series . from_list ( [ 1 , 2.0 ] ) # Explorer.Series &lt; float [ 2 ] [ 1.0 , 2.0 ] &gt; Trying to create a &quot;nil&quot; series will, by default, result in a series of floats. iex&gt; Explorer.Series . from_list ( [ nil , nil ] ) # Explorer.Series &lt; float [ 2 ] [ nil , nil ] &gt; You can specify the desired dtype for a series with the :dtype option. iex&gt; Explorer.Series . from_list ( [ nil , nil ] , dtype : :integer ) # Explorer.Series &lt; integer [ 2 ] [ nil , nil ] &gt; iex&gt; Explorer.Series . from_list ( [ 1 , nil ] , dtype : :string ) # Explorer.Series &lt; string [ 2 ] [ &quot;1&quot; , nil ] &gt; It is possible to create a series of :datetime from a list of microseconds since Unix Epoch. iex&gt; Explorer.Series . from_list ( [ 1649883642 * 1_000 * 1_000 ] , dtype : :datetime ) # Explorer.Series &lt; datetime [ 1 ] [ 2022 - 04 - 13 21 : 00 : 42.000000 ] &gt; Mixing non-numeric data types will raise an ArgumentError. iex&gt; Explorer.Series . from_list ( [ 1 , &quot;a&quot; ] ) ** (ArgumentError) the value &quot;a&quot; does not match the inferred series dtype :integer","ref":"Explorer.Series.html#from_list/2","title":"Explorer.Series.from_list/2","type":"function"},{"doc":"Converts a t:Nx.Tensor.t/0 to a series. Warning Nx is an optional dependency. You will need to ensure it's installed to use this function. Examples iex&gt; tensor = Nx . tensor ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . from_tensor ( tensor ) # Explorer.Series &lt; integer [ 3 ] [ 1 , 2 , 3 ] &gt; iex&gt; tensor = Nx . tensor ( [ 1.0 , 2.0 , 3.0 ] ) iex&gt; Explorer.Series . from_tensor ( tensor ) # Explorer.Series &lt; float [ 3 ] [ 1.0 , 2.0 , 3.0 ] &gt;","ref":"Explorer.Series.html#from_tensor/2","title":"Explorer.Series.from_tensor/2","type":"function"},{"doc":"Returns the value of the series at the given index. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . get ( s , 2 ) &quot;c&quot; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . get ( s , 4 ) ** (ArgumentError) index 4 out of bounds for series of size 3","ref":"Explorer.Series.html#get/2","title":"Explorer.Series.get/2","type":"function"},{"doc":"Returns boolean mask of left &gt; right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . greater ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ false , false , false ] &gt;","ref":"Explorer.Series.html#greater/2","title":"Explorer.Series.greater/2","type":"function"},{"doc":"Returns boolean mask of left &gt;= right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . greater_equal ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ true , true , false ] &gt;","ref":"Explorer.Series.html#greater_equal/2","title":"Explorer.Series.greater_equal/2","type":"function"},{"doc":"Returns the first N elements of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . head ( s ) # Explorer.Series &lt; integer [ 10 ] [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] &gt;","ref":"Explorer.Series.html#head/2","title":"Explorer.Series.head/2","type":"function"},{"doc":"Returns the last element of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . last ( s ) 100","ref":"Explorer.Series.html#last/1","title":"Explorer.Series.last/1","type":"function"},{"doc":"Returns boolean mask of left &lt; right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . less ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ false , false , true ] &gt;","ref":"Explorer.Series.html#less/2","title":"Explorer.Series.less/2","type":"function"},{"doc":"Returns boolean mask of left &lt;= right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . less_equal ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ true , true , true ] &gt;","ref":"Explorer.Series.html#less_equal/2","title":"Explorer.Series.less_equal/2","type":"function"},{"doc":"Gets the maximum value of the series. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . max ( s ) 3 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . max ( s ) 3.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . max ( s ) ~D[2021-01-01] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . max ( s ) ~N[2021-01-01 00:00:00.000000] iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . max ( s ) ** (ArgumentError) Explorer.Series.max/1 not implemented for dtype :string. Valid dtypes are [:integer, :float, :date, :datetime].","ref":"Explorer.Series.html#max/1","title":"Explorer.Series.max/1","type":"function"},{"doc":"Gets the mean value of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . mean ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . mean ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . mean ( s ) ** (ArgumentError) Explorer.Series.mean/1 not implemented for dtype :date. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#mean/1","title":"Explorer.Series.mean/1","type":"function"},{"doc":"Gets the median value of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . median ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . median ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . median ( s ) ** (ArgumentError) Explorer.Series.median/1 not implemented for dtype :date. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#median/1","title":"Explorer.Series.median/1","type":"function"},{"doc":"Gets the minimum value of the series. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . min ( s ) 1 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . min ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . min ( s ) ~D[1999-12-31] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . min ( s ) ~N[1999-12-31 00:00:00.000000] iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . min ( s ) ** (ArgumentError) Explorer.Series.min/1 not implemented for dtype :string. Valid dtypes are [:integer, :float, :date, :datetime].","ref":"Explorer.Series.html#min/1","title":"Explorer.Series.min/1","type":"function"},{"doc":"Multiplies left and right, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float Examples iex&gt; s1 = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = 11 .. 20 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . multiply ( s1 , s2 ) # Explorer.Series &lt; integer [ 10 ] [ 11 , 24 , 39 , 56 , 75 , 96 , 119 , 144 , 171 , 200 ] &gt; iex&gt; s1 = 1 .. 5 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . multiply ( s1 , 2 ) # Explorer.Series &lt; integer [ 5 ] [ 2 , 4 , 6 , 8 , 10 ] &gt;","ref":"Explorer.Series.html#multiply/2","title":"Explorer.Series.multiply/2","type":"function"},{"doc":"Returns the number of unique values in the series. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; , &quot;b&quot; ] ) iex&gt; Explorer.Series . n_distinct ( s ) 2","ref":"Explorer.Series.html#n_distinct/1","title":"Explorer.Series.n_distinct/1","type":"function"},{"doc":"Returns a mask of nil values. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . nil? ( s ) # Explorer.Series &lt; boolean [ 4 ] [ false , false , true , false ] &gt;","ref":"Explorer.Series.html#nil?/1","title":"Explorer.Series.nil?/1","type":"function"},{"doc":"Returns boolean mask of left != right , element-wise. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . not_equal ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ false , false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . not_equal ( s , 1 ) # Explorer.Series &lt; boolean [ 3 ] [ false , true , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ true , true , false ] ) iex&gt; Explorer.Series . not_equal ( s , true ) # Explorer.Series &lt; boolean [ 3 ] [ false , false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . not_equal ( s , &quot;a&quot; ) # Explorer.Series &lt; boolean [ 3 ] [ false , true , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . not_equal ( s , ~D[1999-12-31] ) # Explorer.Series &lt; boolean [ 2 ] [ true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~N[2022-01-01 00:00:00] , ~N[2022-01-01 23:00:00] ] ) iex&gt; Explorer.Series . not_equal ( s , ~N[2022-01-01 00:00:00] ) # Explorer.Series &lt; boolean [ 2 ] [ false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . not_equal ( s , false ) ** (ArgumentError) cannot invoke Explorer.Series.not_equal/2 with mismatched dtypes: string and false.","ref":"Explorer.Series.html#not_equal/2","title":"Explorer.Series.not_equal/2","type":"function"},{"doc":"Returns a mask of not nil values. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . not_nil? ( s ) # Explorer.Series &lt; boolean [ 4 ] [ true , true , false , true ] &gt;","ref":"Explorer.Series.html#not_nil?/1","title":"Explorer.Series.not_nil?/1","type":"function"},{"doc":"Returns a boolean mask of left or right , element-wise Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; mask1 = Explorer.Series . less ( s1 , 2 ) iex&gt; mask2 = Explorer.Series . greater ( s1 , 2 ) iex&gt; Explorer.Series . or ( mask1 , mask2 ) # Explorer.Series &lt; boolean [ 3 ] [ true , false , true ] &gt;","ref":"Explorer.Series.html#or/2","title":"Explorer.Series.or/2","type":"function"},{"doc":"Returns a boolean mask with true where the 'peaks' (series max or min, default max) are. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 4 , 1 , 4 ] ) iex&gt; Explorer.Series . peaks ( s ) # Explorer.Series &lt; boolean [ 5 ] [ false , false , true , false , true ] &gt;","ref":"Explorer.Series.html#peaks/2","title":"Explorer.Series.peaks/2","type":"function"},{"doc":"Raises a numeric series to the power of the exponent. Supported dtypes :integer :float Examples iex&gt; s = [ 8 , 16 , 32 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . pow ( s , 2.0 ) # Explorer.Series &lt; float [ 3 ] [ 64.0 , 256.0 , 1024.0 ] &gt; iex&gt; s = [ 2 , 4 , 6 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . pow ( s , 3 ) # Explorer.Series &lt; integer [ 3 ] [ 8 , 64 , 216 ] &gt; iex&gt; s = [ 2 , 4 , 6 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . pow ( s , - 3.0 ) # Explorer.Series &lt; float [ 3 ] [ 0.125 , 0.015625 , 0.004629629629629629 ] &gt; iex&gt; s = [ 1.0 , 2.0 , 3.0 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . pow ( 3.0 ) # Explorer.Series &lt; float [ 3 ] [ 1.0 , 8.0 , 27.0 ] &gt; iex&gt; s = [ 2.0 , 4.0 , 6.0 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . pow ( 2 ) # Explorer.Series &lt; float [ 3 ] [ 4.0 , 16.0 , 36.0 ] &gt;","ref":"Explorer.Series.html#pow/2","title":"Explorer.Series.pow/2","type":"function"},{"doc":"Gets the given quantile of the series. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . quantile ( s , 0.2 ) 1 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ~D[2021-01-01] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ~N[2021-01-01 00:00:00.000000] iex&gt; s = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ** (ArgumentError) Explorer.Series.quantile/2 not implemented for dtype :boolean. Valid dtypes are [:integer, :float, :date, :datetime].","ref":"Explorer.Series.html#quantile/2","title":"Explorer.Series.quantile/2","type":"function"},{"doc":"Reverses the series order. Example iex&gt; s = [ 1 , 2 , 3 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . reverse ( s ) # Explorer.Series &lt; integer [ 3 ] [ 3 , 2 , 1 ] &gt;","ref":"Explorer.Series.html#reverse/1","title":"Explorer.Series.reverse/1","type":"function"},{"doc":"Returns a random sample of the series. If given an integer as the second argument, it will return N samples. If given a float, it will return that proportion of the series. Can sample with or without replacement. Options replacement - If set to true , each sample will be independent and therefore values may repeat. Required to be true for n greater then the number of rows in the series or frac &gt; 1.0. (default: false ) seed - An integer to be used as a random seed. If nil, a random value between 1 and 1e12 will be used. (default: nil) Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sample ( s , 10 , seed : 100 ) # Explorer.Series &lt; integer [ 10 ] [ 72 , 33 , 15 , 4 , 16 , 49 , 23 , 96 , 45 , 47 ] &gt; iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sample ( s , 0.05 , seed : 100 ) # Explorer.Series &lt; integer [ 5 ] [ 68 , 24 , 6 , 8 , 36 ] &gt;","ref":"Explorer.Series.html#sample/3","title":"Explorer.Series.sample/3","type":"function"},{"doc":"Returns the size of the series. Examples iex&gt; s = Explorer.Series . from_list ( [ ~D[1999-12-31] , ~D[1989-01-01] ] ) iex&gt; Explorer.Series . size ( s ) 2","ref":"Explorer.Series.html#size/1","title":"Explorer.Series.size/1","type":"function"},{"doc":"Returns a slice of the series, with size elements starting at offset . Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , 1 , 2 ) # Explorer.Series &lt; integer [ 2 ] [ 2 , 3 ] &gt; Negative offsets count from the end of the series. iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , - 3 , 2 ) # Explorer.Series &lt; integer [ 2 ] [ 3 , 4 ] &gt; If the size would run past the end of the series, the result may be shorter than the size. iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , - 3 , 4 ) # Explorer.Series &lt; integer [ 3 ] [ 3 , 4 , 5 ] &gt;","ref":"Explorer.Series.html#slice/3","title":"Explorer.Series.slice/3","type":"function"},{"doc":"Sorts the series. Examples iex&gt; s = Explorer.Series . from_list ( [ 9 , 3 , 7 , 1 ] ) iex&gt; s |&gt; Explorer.Series . sort ( ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 3 , 7 , 9 ] &gt;","ref":"Explorer.Series.html#sort/2","title":"Explorer.Series.sort/2","type":"function"},{"doc":"Gets the standard deviation of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . std ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . std ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . std ( s ) ** (ArgumentError) Explorer.Series.std/1 not implemented for dtype :string. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#std/1","title":"Explorer.Series.std/1","type":"function"},{"doc":"Subtracts right from left, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.Series . subtract ( s1 , s2 ) # Explorer.Series &lt; integer [ 3 ] [ - 3 , - 3 , - 3 ] &gt;","ref":"Explorer.Series.html#subtract/2","title":"Explorer.Series.subtract/2","type":"function"},{"doc":"Gets the sum of the series. Supported dtypes :integer :float :boolean Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . sum ( s ) 6 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . sum ( s ) 6.0 iex&gt; s = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . sum ( s ) 2 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . sum ( s ) ** (ArgumentError) Explorer.Series.sum/1 not implemented for dtype :date. Valid dtypes are [:integer, :float, :boolean].","ref":"Explorer.Series.html#sum/1","title":"Explorer.Series.sum/1","type":"function"},{"doc":"Returns the last N elements of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . tail ( s ) # Explorer.Series &lt; integer [ 10 ] [ 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 ] &gt;","ref":"Explorer.Series.html#tail/2","title":"Explorer.Series.tail/2","type":"function"},{"doc":"Returns the elements at the given indices as a new series. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . take ( s , [ 0 , 2 ] ) # Explorer.Series &lt; string [ 2 ] [ &quot;a&quot; , &quot;c&quot; ] &gt;","ref":"Explorer.Series.html#take/2","title":"Explorer.Series.take/2","type":"function"},{"doc":"Takes every n th value in this series, returned as a new series. Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . take_every ( 2 ) # Explorer.Series &lt; integer [ 5 ] [ 1 , 3 , 5 , 7 , 9 ] &gt; If n is bigger than the size of the series, the result is a new series with only the first value of the supplied series. iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . take_every ( 20 ) # Explorer.Series &lt; integer [ 1 ] [ 1 ] &gt;","ref":"Explorer.Series.html#take_every/2","title":"Explorer.Series.take_every/2","type":"function"},{"doc":"Converts a series to an enumerable. Examples iex&gt; series = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; series |&gt; Explorer.Series . to_enum ( ) |&gt; Enum . to_list ( ) [ 1 , 2 , 3 ]","ref":"Explorer.Series.html#to_enum/1","title":"Explorer.Series.to_enum/1","type":"function"},{"doc":"Converts a series to a list. Examples iex&gt; series = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_list ( series ) [ 1 , 2 , 3 ]","ref":"Explorer.Series.html#to_list/1","title":"Explorer.Series.to_list/1","type":"function"},{"doc":"Converts a series to a t:Nx.Tensor.t/0 . Options are passed directly to Nx.tensor/2 . Supported dtypes :float :integer Warning Nx is an optional dependency. You will need to ensure it's installed to use this function. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_tensor ( s ) # Nx.Tensor &lt; s64 [ 3 ] [ 1 , 2 , 3 ] &gt; Tensor options can be passed directly to to_tensor/2 . iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_tensor ( s , names : [ :y ] , type : { :f , 64 } ) # Nx.Tensor &lt; f64 [ y : 3 ] [ 1.0 , 2.0 , 3.0 ] &gt;","ref":"Explorer.Series.html#to_tensor/2","title":"Explorer.Series.to_tensor/2","type":"function"},{"doc":"Returns an Explorer.Series where each element is the result of invoking fun on each corresponding element of series . This is an expensive operation meant to enable the use of arbitrary Elixir functions against any backend. The implementation will vary by backend but in most (all?) cases will require converting to an Elixir.List , applying Enum.map/2 , and then converting back to an Explorer.Series . Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;this &quot; , &quot; is&quot; , &quot;great &quot; ] ) iex&gt; Explorer.Series . transform ( s , &amp; String . trim / 1 ) # Explorer.Series &lt; string [ 3 ] [ &quot;this&quot; , &quot;is&quot; , &quot;great&quot; ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;this&quot; , &quot;is&quot; , &quot;great&quot; ] ) iex&gt; Explorer.Series . transform ( s , &amp; String . length / 1 ) # Explorer.Series &lt; integer [ 3 ] [ 4 , 2 , 5 ] &gt;","ref":"Explorer.Series.html#transform/2","title":"Explorer.Series.transform/2","type":"function"},{"doc":"Returns the unique values of the series, but does not maintain order. Faster than distinct/1 . Examples iex&gt; s = [ 1 , 1 , 2 , 2 , 3 , 3 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . unordered_distinct ( )","ref":"Explorer.Series.html#unordered_distinct/1","title":"Explorer.Series.unordered_distinct/1","type":"function"},{"doc":"Gets the variance of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . var ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . var ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . var ( s ) ** (ArgumentError) Explorer.Series.var/1 not implemented for dtype :datetime. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#var/1","title":"Explorer.Series.var/1","type":"function"},{"doc":"Calculate the rolling max, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_max ( s , 4 ) # Explorer.Series &lt; integer [ 10 ] [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_max ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; float [ 10 ] [ 1.0 , 4.0 , 6.0 , 8.0 , 10.0 , 12.0 , 14.0 , 16.0 , 18.0 , 20.0 ] &gt;","ref":"Explorer.Series.html#window_max/3","title":"Explorer.Series.window_max/3","type":"function"},{"doc":"Calculate the rolling mean, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_mean ( s , 4 ) # Explorer.Series &lt; float [ 10 ] [ 1.0 , 1.5 , 2.0 , 2.5 , 3.5 , 4.5 , 5.5 , 6.5 , 7.5 , 8.5 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_mean ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; float [ 10 ] [ 1.0 , 2.5 , 4.0 , 5.5 , 7.0 , 8.5 , 10.0 , 11.5 , 13.0 , 14.5 ] &gt;","ref":"Explorer.Series.html#window_mean/3","title":"Explorer.Series.window_mean/3","type":"function"},{"doc":"Calculate the rolling min, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_min ( s , 4 ) # Explorer.Series &lt; integer [ 10 ] [ 1 , 1 , 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_min ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; float [ 10 ] [ 1.0 , 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 ] &gt;","ref":"Explorer.Series.html#window_min/3","title":"Explorer.Series.window_min/3","type":"function"},{"doc":"Calculate the rolling sum, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_sum ( s , 4 ) # Explorer.Series &lt; integer [ 10 ] [ 1 , 3 , 6 , 10 , 14 , 18 , 22 , 26 , 30 , 34 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . window_sum ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; float [ 10 ] [ 1.0 , 5.0 , 8.0 , 11.0 , 14.0 , 17.0 , 20.0 , 23.0 , 26.0 , 29.0 ] &gt;","ref":"Explorer.Series.html#window_sum/3","title":"Explorer.Series.window_sum/3","type":"function"},{"doc":"","ref":"Explorer.Series.html#t:data/0","title":"Explorer.Series.data/0","type":"type"},{"doc":"","ref":"Explorer.Series.html#t:dtype/0","title":"Explorer.Series.dtype/0","type":"type"},{"doc":"","ref":"Explorer.Series.html#t:t/0","title":"Explorer.Series.t/0","type":"type"},{"doc":"The behaviour for Explorer backends and associated functions. Each backend is a module with DataFrame and Series submodules that match the respective behaviours for each. The default backend is read from the application environment. Currently, the only backend is an in-memory, eager one based on Polars . When alternatives are available, you can use them by configuring your runtime: # config/runtime.exs import Config config :explorer , default_backend : Lib.CustomBackend","ref":"Explorer.Backend.html","title":"Explorer.Backend","type":"module"},{"doc":"Gets the default backend for the current process.","ref":"Explorer.Backend.html#get/0","title":"Explorer.Backend.get/0","type":"function"},{"doc":"Sets the current process default backend to backend . The default backend is stored only in the process dictionary. This means if you start a separate process, such as Task , the default backend must be set on the new process too. Examples iex&gt; Explorer.Backend . put ( Lib.CustomBackend ) Explorer.PolarsBackend iex&gt; Explorer.Backend . get ( ) Lib.CustomBackend","ref":"Explorer.Backend.html#put/1","title":"Explorer.Backend.put/1","type":"function"},{"doc":"The behaviour for DataFrame backends.","ref":"Explorer.Backend.DataFrame.html","title":"Explorer.Backend.DataFrame","type":"behaviour"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:arrange/2","title":"Explorer.Backend.DataFrame.arrange/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:collect/1","title":"Explorer.Backend.DataFrame.collect/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:concat_rows/1","title":"Explorer.Backend.DataFrame.concat_rows/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:distinct/3","title":"Explorer.Backend.DataFrame.distinct/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:drop_nil/2","title":"Explorer.Backend.DataFrame.drop_nil/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dtypes/1","title":"Explorer.Backend.DataFrame.dtypes/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dummies/2","title":"Explorer.Backend.DataFrame.dummies/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dump_csv/3","title":"Explorer.Backend.DataFrame.dump_csv/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:filter/2","title":"Explorer.Backend.DataFrame.filter/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_csv/11","title":"Explorer.Backend.DataFrame.from_csv/11","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_ipc/2","title":"Explorer.Backend.DataFrame.from_ipc/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_ndjson/3","title":"Explorer.Backend.DataFrame.from_ndjson/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_parquet/1","title":"Explorer.Backend.DataFrame.from_parquet/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_series/1","title":"Explorer.Backend.DataFrame.from_series/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_tabular/1","title":"Explorer.Backend.DataFrame.from_tabular/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:group_by/2","title":"Explorer.Backend.DataFrame.group_by/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:head/2","title":"Explorer.Backend.DataFrame.head/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:inspect/2","title":"Explorer.Backend.DataFrame.inspect/2","type":"callback"},{"doc":"Default inspect implementation for backends.","ref":"Explorer.Backend.DataFrame.html#inspect/5","title":"Explorer.Backend.DataFrame.inspect/5","type":"function"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:join/4","title":"Explorer.Backend.DataFrame.join/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:lazy/0","title":"Explorer.Backend.DataFrame.lazy/0","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:mutate/2","title":"Explorer.Backend.DataFrame.mutate/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:n_columns/1","title":"Explorer.Backend.DataFrame.n_columns/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:n_rows/1","title":"Explorer.Backend.DataFrame.n_rows/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:names/1","title":"Explorer.Backend.DataFrame.names/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:pivot_longer/5","title":"Explorer.Backend.DataFrame.pivot_longer/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:pivot_wider/5","title":"Explorer.Backend.DataFrame.pivot_wider/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:pull/2","title":"Explorer.Backend.DataFrame.pull/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:rename/2","title":"Explorer.Backend.DataFrame.rename/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:sample/4","title":"Explorer.Backend.DataFrame.sample/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:select/3","title":"Explorer.Backend.DataFrame.select/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:shape/1","title":"Explorer.Backend.DataFrame.shape/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:slice/3","title":"Explorer.Backend.DataFrame.slice/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:summarise/2","title":"Explorer.Backend.DataFrame.summarise/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:tail/2","title":"Explorer.Backend.DataFrame.tail/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:take/2","title":"Explorer.Backend.DataFrame.take/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_csv/4","title":"Explorer.Backend.DataFrame.to_csv/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_ipc/3","title":"Explorer.Backend.DataFrame.to_ipc/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_lazy/1","title":"Explorer.Backend.DataFrame.to_lazy/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_ndjson/2","title":"Explorer.Backend.DataFrame.to_ndjson/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_parquet/2","title":"Explorer.Backend.DataFrame.to_parquet/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_rows/2","title":"Explorer.Backend.DataFrame.to_rows/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:ungroup/2","title":"Explorer.Backend.DataFrame.ungroup/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:column_name/0","title":"Explorer.Backend.DataFrame.column_name/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:df/0","title":"Explorer.Backend.DataFrame.df/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:dtype/0","title":"Explorer.Backend.DataFrame.dtype/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:result/1","title":"Explorer.Backend.DataFrame.result/1","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:series/0","title":"Explorer.Backend.DataFrame.series/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:t/0","title":"Explorer.Backend.DataFrame.t/0","type":"type"},{"doc":"The behaviour for series backends.","ref":"Explorer.Backend.Series.html","title":"Explorer.Backend.Series","type":"behaviour"},{"doc":"","ref":"Explorer.Backend.Series.html#c:add/2","title":"Explorer.Backend.Series.add/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:all_equal?/2","title":"Explorer.Backend.Series.all_equal?/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:argsort/2","title":"Explorer.Backend.Series.argsort/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:binary_and/2","title":"Explorer.Backend.Series.binary_and/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:binary_or/2","title":"Explorer.Backend.Series.binary_or/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cast/2","title":"Explorer.Backend.Series.cast/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:coalesce/2","title":"Explorer.Backend.Series.coalesce/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:concat/2","title":"Explorer.Backend.Series.concat/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:count/1","title":"Explorer.Backend.Series.count/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cumulative_max/2","title":"Explorer.Backend.Series.cumulative_max/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cumulative_min/2","title":"Explorer.Backend.Series.cumulative_min/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cumulative_sum/2","title":"Explorer.Backend.Series.cumulative_sum/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:distinct/1","title":"Explorer.Backend.Series.distinct/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:divide/2","title":"Explorer.Backend.Series.divide/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:dtype/1","title":"Explorer.Backend.Series.dtype/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:eq/2","title":"Explorer.Backend.Series.eq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:fill_missing/2","title":"Explorer.Backend.Series.fill_missing/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:filter/2","title":"Explorer.Backend.Series.filter/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:from_list/2","title":"Explorer.Backend.Series.from_list/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:get/2","title":"Explorer.Backend.Series.get/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:gt/2","title":"Explorer.Backend.Series.gt/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:gt_eq/2","title":"Explorer.Backend.Series.gt_eq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:head/2","title":"Explorer.Backend.Series.head/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:inspect/2","title":"Explorer.Backend.Series.inspect/2","type":"callback"},{"doc":"Default inspect implementation for backends.","ref":"Explorer.Backend.Series.html#inspect/5","title":"Explorer.Backend.Series.inspect/5","type":"function"},{"doc":"","ref":"Explorer.Backend.Series.html#c:lt/2","title":"Explorer.Backend.Series.lt/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:lt_eq/2","title":"Explorer.Backend.Series.lt_eq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:max/1","title":"Explorer.Backend.Series.max/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:mean/1","title":"Explorer.Backend.Series.mean/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:median/1","title":"Explorer.Backend.Series.median/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:min/1","title":"Explorer.Backend.Series.min/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:multiply/2","title":"Explorer.Backend.Series.multiply/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:n_distinct/1","title":"Explorer.Backend.Series.n_distinct/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:neq/2","title":"Explorer.Backend.Series.neq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:nil?/1","title":"Explorer.Backend.Series.nil?/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:not_nil?/1","title":"Explorer.Backend.Series.not_nil?/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:peaks/2","title":"Explorer.Backend.Series.peaks/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:pow/2","title":"Explorer.Backend.Series.pow/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:quantile/2","title":"Explorer.Backend.Series.quantile/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:reverse/1","title":"Explorer.Backend.Series.reverse/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sample/4","title":"Explorer.Backend.Series.sample/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:size/1","title":"Explorer.Backend.Series.size/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:slice/3","title":"Explorer.Backend.Series.slice/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sort/2","title":"Explorer.Backend.Series.sort/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:std/1","title":"Explorer.Backend.Series.std/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:subtract/2","title":"Explorer.Backend.Series.subtract/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sum/1","title":"Explorer.Backend.Series.sum/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:tail/2","title":"Explorer.Backend.Series.tail/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:take/2","title":"Explorer.Backend.Series.take/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:take_every/2","title":"Explorer.Backend.Series.take_every/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:to_enum/1","title":"Explorer.Backend.Series.to_enum/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:to_list/1","title":"Explorer.Backend.Series.to_list/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:transform/2","title":"Explorer.Backend.Series.transform/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:unordered_distinct/1","title":"Explorer.Backend.Series.unordered_distinct/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:var/1","title":"Explorer.Backend.Series.var/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:window_max/3","title":"Explorer.Backend.Series.window_max/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:window_mean/3","title":"Explorer.Backend.Series.window_mean/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:window_min/3","title":"Explorer.Backend.Series.window_min/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:window_sum/3","title":"Explorer.Backend.Series.window_sum/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#t:df/0","title":"Explorer.Backend.Series.df/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:dtype/0","title":"Explorer.Backend.Series.dtype/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:s/0","title":"Explorer.Backend.Series.s/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:t/0","title":"Explorer.Backend.Series.t/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:window_option/0","title":"Explorer.Backend.Series.window_option/0","type":"type"},{"doc":"The Explorer backend for Polars.","ref":"Explorer.PolarsBackend.html","title":"Explorer.PolarsBackend","type":"module"},{"doc":"","ref":"exploring_explorer.html","title":"Ten Minutes to Explorer","type":"extras"},{"doc":"Explorer is a dataframe library for Elixir. A dataframe is a common data structure used in data analysis. It is a two-dimensional table composed of columns and rows similar to a SQL table or a spreadsheet. Explorer's aim is to provide a simple and powerful API for manipulating dataframes. It takes influences mainly from the tidyverse , but if you've used other dataframe libraries like pandas you shouldn't have too much trouble working with Explorer. This document is meant to give you a crash course in using Explorer. More in-depth documentation can be found in the relevant sections of the docs. We strongly recommend you run this livebook locally so you can see the outputs and play with the inputs!","ref":"exploring_explorer.html#introduction","title":"Ten Minutes to Explorer - Introduction","type":"extras"},{"doc":"Connect to a Mix project with Explorer installed or: Mix . install ( [ { :explorer , &quot;~&gt; 0.1.1&quot; } , { :kino , &quot;~&gt; 0.4.1&quot; } ] )","ref":"exploring_explorer.html#installation","title":"Ten Minutes to Explorer - Installation","type":"extras"},{"doc":"Data can be read from delimited files (like CSV), NDJSON, Parquet, and the Arrow IPC (feather) format. You can also load in data from a map or keyword list of columns with Explorer.DataFrame.new/1 . For CSV, your 'usual suspects' of options are available: delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) dtypes - A keyword list of [column_name: dtype] . If a type is not specified for a column, it is imputed from the first 1000 rows. (default: [] ) header - Does the file have a header of column names as the first row or not? (default: true ) max_rows - Maximum number of lines to read. (default: nil ) null_character - The string that should be interpreted as a nil value. (default: &quot;NA&quot; ) skip_rows - The number of lines to skip at the beginning of the file. (default: 0 ) columns - A list of column names to keep. If present, only these columns are read into the dataframe. (default: nil ) Explorer also has multiple example datasets built in, which you can load from the Explorer.Datasets module like so: df = Explorer.Datasets . fossil_fuels ( ) You'll notice that the output looks slightly different than many dataframe libraries. Explorer takes inspiration on this front from glimpse in R. A benefit to this approach is that you will rarely need to elide columns. If you'd like to see a table with your data, we've got you covered there too. Explorer.DataFrame . table ( df ) Writing files is very similar to reading them. The options are a little more limited: header - Should the column names be written as the first line of the file? (default: true ) delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) First, let's add some useful aliases: alias Explorer.DataFrame alias Explorer.Series And then write to a file of your choosing: input = Kino.Input . text ( &quot;Filename&quot; ) filename = Kino.Input . read ( input ) DataFrame . to_csv ( df , filename )","ref":"exploring_explorer.html#reading-and-writing-data","title":"Ten Minutes to Explorer - Reading and writing data","type":"extras"},{"doc":"Explorer , like Polars , works up from the concept of a Series . In many ways, you can think of a dataframe as a row-aligned map of Series . These are like vectors in R or series in Pandas. For simplicity, Explorer uses the following Series dtypes : :float - 64-bit floating point number :integer - 64-bit signed integer :boolean - Boolean :string - UTF-8 encoded binary :date - Date type that unwraps to Elixir.Date :datetime - DateTime type that unwraps to Elixir.NaiveDateTime Series can be constructed from Elixir basic types. For example: s1 = Series . from_list ( [ 1 , 2 , 3 ] ) s2 = Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) s3 = Series . from_list ( [ ~D[2011-01-01] , ~D[1965-01-21] ] ) You'll notice that the dtype and size of the Series are at the top of the printed value. You can get those programmatically as well. Series . dtype ( s3 ) Series . size ( s3 ) And the printed values max out at 50: 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) Series are also nullable. s = Series . from_list ( [ 1.0 , 2.0 , nil , nil , 5.0 ] ) And you can fill in those missing values using one of the following strategies: :forward - replace nil with the previous value :backward - replace nil with the next value :max - replace nil with the series maximum :min - replace nil with the series minimum :mean - replace nil with the series mean Series . fill_missing ( s , :forward ) In the case of mixed numeric types (i.e. integers and floats), Series will downcast to a float: Series . from_list ( [ 1 , 2.0 ] ) In all other cases, Series must all be of the same dtype or else you'll get an ArgumentError . Series . from_list ( [ 1 , 2 , 3 , &quot;a&quot; ] ) One of the goals of Explorer is useful error messages . If you look at the error above, you get: Cannot make a series from mismatched types. Type of &quot;a&quot; does not match inferred dtype integer. Hopefully this makes abundantly clear what's going on. Series also implements the Access protocol. You can slice and dice in many ways: s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) s [ 1 ] s [ - 1 ] s [ 0 .. 4 ] s [ [ 0 , 4 , 4 ] ] And of course, you can convert back to an Elixir list. Series . to_list ( s ) Explorer supports comparisons. s = 1 .. 11 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) s1 = 11 .. 1 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) Series . equal ( s , s1 ) Series . equal ( s , 5 ) Series . not_equal ( s , 10 ) Series . greater_equal ( s , 4 ) And arithmetic. Series . add ( s , s1 ) Series . subtract ( s , 4 ) Series . multiply ( s , s1 ) Remember those helpful errors? We've tried to add those throughout. So if you try to do arithmetic with mismatching dtypes: s = Series . from_list ( [ 1 , 2 , 3 ] ) s1 = Series . from_list ( [ 1.0 , 2.0 , 3.0 ] ) Series . add ( s , s1 ) Just kidding! Integers and floats will downcast to floats. Let's try again: s = Series . from_list ( [ 1 , 2 , 3 ] ) s1 = Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) Series . add ( s , s1 ) You can flip them around. s = Series . from_list ( [ 1 , 2 , 3 , 4 ] ) Series . reverse ( s ) And sort. 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Enum . shuffle ( ) |&gt; Series . from_list ( ) |&gt; Series . sort ( ) Or argsort. s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Enum . shuffle ( ) |&gt; Series . from_list ( ) ids = Series . argsort ( s ) Which you can pass to Explorer.Series.take/2 if you want the sorted values. Series . take ( s , ids ) You can calculate cumulative values. s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Series . from_list ( ) Series . cum_sum ( s ) Or rolling ones. Series . rolling_sum ( s , 4 ) You can count and list unique values. s = Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; , &quot;c&quot; , &quot;c&quot; , &quot;c&quot; ] ) Series . distinct ( s ) Series . n_distinct ( s ) And you can even get a dataframe showing the counts for each distinct value. Series . count ( s )","ref":"exploring_explorer.html#working-with-series","title":"Ten Minutes to Explorer - Working with Series","type":"extras"},{"doc":"A DataFrame is really just a collection of Series of the same size. Which is why you can create a DataFrame from a Keyword list. DataFrame . new ( a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) Similarly to Series , the Inspect implementation prints some info at the top and to the left. At the top we see the shape of the dataframe (rows and columns) and then for each column we see the name, dtype, and first five values. We can see a bit more from that built-in dataset we loaded in earlier. df You will also see grouping information there, but we'll get to that later. You can get the info yourself directly: DataFrame . names ( df ) DataFrame . dtypes ( df ) DataFrame . shape ( df ) { DataFrame . n_rows ( df ) , DataFrame . n_columns ( df ) } We can grab the head. DataFrame . head ( df ) Or the tail. Let's get a few more values from the tail. DataFrame . tail ( df , 10 ) Select Let's jump right into it. We can select columns pretty simply. DataFrame . select ( df , [ &quot;year&quot; , &quot;country&quot; ] ) But Elixir gives us some superpowers. In R there's tidy-select . I don't think we need that in Elixir. Anywhere in Explorer where you need to pass a list of column names, you can also execute a filtering callback on the column names. It's just an anonymous function passed to df |&gt; DataFrame.names() |&gt; Enum.filter(callback_here) . DataFrame . select ( df , &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) ) Want all but some columns? DataFrame.select/3 takes :keep or :drop as the last arg. It just defaults to :keep . DataFrame . select ( df , &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) , :drop ) Filter The next verb we'll look at is filter . You can pass in a boolean mask series of the same size as the dataframe, but I find it's more handy to use callbacks on the dataframe to generate those masks. DataFrame . filter ( df , &amp; Series . equal ( &amp;1 [ &quot;country&quot; ] , &quot;AFGHANISTAN&quot; ) ) filtered_df = df |&gt; DataFrame . filter ( &amp; Series . equal ( &amp;1 [ &quot;country&quot; ] , &quot;ALGERIA&quot; ) ) |&gt; DataFrame . filter ( &amp; Series . greater ( &amp;1 [ &quot;year&quot; ] , 2012 ) ) DataFrame . filter ( filtered_df , [ true , false ] ) Remember those helpful error messages? DataFrame . filter ( df , &amp; Series . equal ( &amp;1 [ &quot;cuontry&quot; ] , &quot;AFGHANISTAN&quot; ) ) Mutate A common task in data analysis is to add columns or change existing ones. Mutate is a handy verb. DataFrame . mutate ( df , new_column : &amp; Series . add ( &amp;1 [ &quot;solid_fuel&quot; ] , &amp;1 [ &quot;cement&quot; ] ) ) Did you catch that? You can pass in new columns as keyword arguments. It also works to transform existing columns. DataFrame . mutate ( df , gas_fuel : &amp; Series . cast ( &amp;1 [ &quot;gas_fuel&quot; ] , :float ) , gas_and_liquid_fuel : &amp; Series . add ( &amp;1 [ &quot;gas_fuel&quot; ] , &amp;1 [ &quot;liquid_fuel&quot; ] ) ) DataFrame.mutate/2 is flexible though. You may not always want to use keyword arguments. Given that column names are String.t() , it may make more sense to use a map. DataFrame . mutate ( df , %{ &quot;gas_fuel&quot; =&gt; &amp; Series . subtract ( &amp;1 [ &quot;gas_fuel&quot; ] , 10 ) } ) DataFrame.transmute/2 , which is DataFrame.mutate/2 that only retains the specified columns, is forthcoming. Arrange Sorting the dataframe is pretty straightforward. DataFrame . arrange ( df , &quot;year&quot; ) But it comes with some tricks up its sleeve. DataFrame . arrange ( df , asc : &quot;total&quot; , desc : &quot;year&quot; ) Sort operations happen left to right. And keyword list args permit specifying the direction. Distinct Okay, as expected here too. Very straightforward. DataFrame . distinct ( df , columns : [ &quot;year&quot; , &quot;country&quot; ] ) You can specify whether to keep the other columns as well. DataFrame . distinct ( df , columns : [ &quot;country&quot; ] , keep_all? : true ) Rename Rename can take either a list of new names or a callback that is passed to Enum.map/2 against the names. You can also use a map or keyword args to rename specific columns. DataFrame . rename ( df , year : &quot;year_test&quot; ) DataFrame . rename ( df , &amp; ( &amp;1 &lt;&gt; &quot;_test&quot; ) ) Dummies This is fun! We can get dummy variables for unique values. DataFrame . dummies ( df , [ &quot;year&quot; ] ) DataFrame . dummies ( df , [ &quot;country&quot; ] ) Sampling Random samples can give us a percent or a specific number of samples, with or without replacement, and the function is seedable. DataFrame . sample ( df , 10 ) DataFrame . sample ( df , 0.4 ) Trying for those helpful error messages again. DataFrame . sample ( df , 10000 ) DataFrame . sample ( df , 10000 , replacement : true ) Pull/slice/take Slicing and dicing can be done with the Access protocol or with explicit pull/slice/take functions. df [ &quot;year&quot; ] DataFrame . pull ( df , &quot;year&quot; ) df [ [ &quot;year&quot; , &quot;country&quot; ] ] DataFrame . take ( df , [ 1 , 20 , 50 ] ) Negative offsets work for slice! DataFrame . slice ( df , - 10 , 5 ) DataFrame . slice ( df , 10 , 5 ) Pivot We can pivot_longer/3 and pivot_wider/4 . These are inspired by tidyr . There are some shortcomings in pivot_wider/4 related to polars . The values_from column must be a numeric type. DataFrame . pivot_longer ( df , [ &quot;year&quot; , &quot;country&quot; ] , value_columns : &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) ) DataFrame . pivot_wider ( df , &quot;country&quot; , &quot;total&quot; , id_columns : [ &quot;year&quot; ] ) Let's make those names look nicer! tidy_names = fn name -&gt; name |&gt; String . downcase ( ) |&gt; String . replace ( ~r/ \\s / , &quot; &quot; ) |&gt; String . replace ( ~r/[^A-Za-z \\s ]/ , &quot;&quot; ) |&gt; String . replace ( &quot; &quot; , &quot;_&quot; ) end df |&gt; DataFrame . pivot_wider ( &quot;country&quot; , &quot;total&quot; , id_columns : [ &quot;year&quot; ] ) |&gt; DataFrame . rename ( tidy_names ) Joins Joining is fast and easy. You can specify the columns to join on and how to join. Polars even supports cartesian (cross) joins, so Explorer does too. df1 = DataFrame . select ( df , [ &quot;year&quot; , &quot;country&quot; , &quot;total&quot; ] ) df2 = DataFrame . select ( df , [ &quot;year&quot; , &quot;country&quot; , &quot;cement&quot; ] ) DataFrame . join ( df1 , df2 ) df3 = df |&gt; DataFrame . select ( [ &quot;year&quot; , &quot;cement&quot; ] ) |&gt; DataFrame . slice ( 0 , 500 ) DataFrame . join ( df1 , df3 , how : :left ) Grouping Explorer supports groupby operations. They're limited based on what's possible in Polars, but they do most of what you need to do. grouped = DataFrame . group_by ( df , [ &quot;country&quot; ] ) Notice that the Inspect call now shows groups as well as rows and columns . You can, of course, get them explicitly. DataFrame . groups ( grouped ) And you can ungroup explicitly. DataFrame . ungroup ( grouped ) But what we care about the most is aggregating! Let's see which country has the max per_capita value. grouped |&gt; DataFrame . summarise ( per_capita : [ :max ] ) |&gt; DataFrame . arrange ( desc : :per_capita_max ) Qatar it is. You can use the following aggregations: :min - Take the minimum value within the group. See Explorer.Series.min/1 . :max - Take the maximum value within the group. See Explorer.Series.max/1 . :sum - Take the sum of the series within the group. See Explorer.Series.sum/1 . :mean - Take the mean of the series within the group. See Explorer.Series.mean/1 . :median - Take the median of the series within the group. See Explorer.Series.median/1 . :first - Take the first value within the group. See Explorer.Series.first/1 . :last - Take the last value within the group. See Explorer.Series.last/1 . :count - Count the number of rows per group. :n_unique - Count the number of unique rows per group. The API is similar to mutate : you can use keyword args or a map and specify aggregations to use. grouped |&gt; DataFrame . summarise ( per_capita : [ :max , :min ] , total : [ :min ] ) Speaking of mutate , it's 'group-aware'. As are arrange , distinct , and n_rows . DataFrame . arrange ( grouped , desc : :total ) That's it! And not. This is certainly not exhaustive, but I hope it gives you a good idea of what can be done and what the 'flavour' of the API is like. I'd love contributions and issues raised where you find them!","ref":"exploring_explorer.html#working-with-dataframes","title":"Ten Minutes to Explorer - Working with DataFrames","type":"extras"},{"doc":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","ref":"changelog.html","title":"Changelog","type":"extras"},{"doc":"Added Consistently support ranges throughout the columns API Support negative indexes throughout the columns API Integrate with the table package Add Series.to_enum/1 for lazily traversing the series Add Series.coalesce/1 and Series.coalesce/2 for finding the first non-null value in a list of series Changed Series.length/1 is now Series.size/1 in keeping with Elixir idioms Nx is now an optional dependency Minimum Elixir version is now 1.13 DataFrame.to_map/2 is now DataFrame.to_columns/2 and DataFrame.to_series/2 Rustler is now an optional dependency read_ and write_ IO functions are now from_ and to_ to_binary is now dump_csv Now uses polars 's &quot;simd&quot; feature Now uses polars 's &quot;performant&quot; feature Explorer.default_backend/0 is now Explorer.Backend.get/0 Explorer.default_backend/1 is now Explorer.Backend.put/1 Series.cum_* functions are now Series.cumulative_* to mirror Nx Series.rolling_* functions are now Series.window_* to mirror Nx reverse? is now an option instead of an argument in Series.cumulative_* functions DataFrame.from_columns/2 and DataFrame.from_rows/2 is now DataFrame.new/2 Rename &quot;col&quot; to &quot;column&quot; throughout the API Remove &quot;with_&quot; prefix in options throughout the API","ref":"changelog.html#unreleased","title":"Changelog - [Unreleased]","type":"extras"},{"doc":"Security Updated Rust dependencies to address Dependabot security alerts: 1 , 2 , 3","ref":"changelog.html#v0-1-1-2022-04-27","title":"Changelog - [v0.1.1] - 2022-04-27","type":"extras"},{"doc":"First release.","ref":"changelog.html#v0-1-0-2022-04-26","title":"Changelog - [v0.1.0] - 2022-04-26","type":"extras"}]