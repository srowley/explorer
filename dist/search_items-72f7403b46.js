searchNodes=[{"doc":"Dataframes for Elixir. The Explorer library is a set of functions and data types to work with tabular data in Elixir. Most of the functionality in Explorer is in Explorer.DataFrame and Explorer.Series . This module handles the default backend for Explorer . The default backend is read from the application environment. When alternatives are available, you can use them by configuring your runtime: # config/runtime.exs import Config config :explorer , default_backend : Lib.CustomBackend","ref":"Explorer.html","title":"Explorer","type":"module"},{"doc":"Gets the default backend for the current process.","ref":"Explorer.html#default_backend/0","title":"Explorer.default_backend/0","type":"function"},{"doc":"Sets the current process default backend to backend . The default backend is stored only in the process dictionary. This means if you start a separate process, such as Task , the default backend must be set on the new process too. Examples iex&gt; Explorer . default_backend ( Lib.CustomBackend ) Explorer.PolarsBackend iex&gt; Explorer . default_backend ( ) Lib.CustomBackend","ref":"Explorer.html#default_backend/1","title":"Explorer.default_backend/1","type":"function"},{"doc":"The DataFrame struct and API.","ref":"Explorer.DataFrame.html","title":"Explorer.DataFrame","type":"module"},{"doc":"Arranges/sorts rows by columns. Examples A single column name will sort ascending by that column: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . arrange ( df , &quot;a&quot; ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 3 , 1 , 2 ] &gt; You can also sort descending: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;b&quot; , &quot;c&quot; , &quot;a&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . arrange ( df , desc : &quot;a&quot; ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] a string [ &quot;c&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 2 , 1 , 3 ] &gt; Sorting by more than one column sorts them in the order they are entered: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . arrange ( df , asc : &quot;total&quot; , desc : &quot;country&quot; ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 10 ] year integer [ 2010 , 2012 , 2011 , 2013 , 2014 , &quot;...&quot; ] country string [ &quot;ZIMBABWE&quot; , &quot;ZIMBABWE&quot; , &quot;ZIMBABWE&quot; , &quot;ZIMBABWE&quot; , &quot;ZIMBABWE&quot; , &quot;...&quot; ] total integer [ 2121 , 2125 , 2608 , 3184 , 3278 , &quot;...&quot; ] solid_fuel integer [ 1531 , 917 , 1584 , 1902 , 2097 , &quot;...&quot; ] liquid_fuel integer [ 481 , 1006 , 888 , 1119 , 1005 , &quot;...&quot; ] gas_fuel integer [ 0 , 0 , 0 , 0 , 0 , &quot;...&quot; ] cement integer [ 109 , 201 , 136 , 162 , 177 , &quot;...&quot; ] gas_flaring integer [ 0 , 0 , 0 , 0 , 0 , &quot;...&quot; ] per_capita float [ 0.15 , 0.15 , 0.18 , 0.21 , 0.22 , &quot;...&quot; ] bunker_fuels integer [ 7 , 9 , 8 , 9 , 9 , &quot;...&quot; ] &gt;","ref":"Explorer.DataFrame.html#arrange/2","title":"Explorer.DataFrame.arrange/2","type":"function"},{"doc":"Combine two or more dataframes row-wise (stack). Column names and dtypes must match exactly. Examples iex&gt; df1 = Explorer.DataFrame . from_map ( %{ x : [ 1 , 2 , 3 ] , y : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] } ) iex&gt; df2 = Explorer.DataFrame . from_map ( %{ x : [ 4 , 5 , 6 ] , y : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] } ) iex&gt; Explorer.DataFrame . concat_rows ( [ df1 , df2 ] ) # Explorer.DataFrame &lt; [ rows : 6 , columns : 2 ] x integer [ 1 , 2 , 3 , 4 , 5 , &quot;...&quot; ] y string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; , &quot;e&quot; , &quot;...&quot; ] &gt;","ref":"Explorer.DataFrame.html#concat_rows/1","title":"Explorer.DataFrame.concat_rows/1","type":"function"},{"doc":"Combine two dataframes row-wise. concat_rows(df1, df2) is equivalent to concat_rows([df1, df2]) .","ref":"Explorer.DataFrame.html#concat_rows/2","title":"Explorer.DataFrame.concat_rows/2","type":"function"},{"doc":"Takes distinct rows by a selection of columns. Examples By default will return unique values of the requested columns: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . distinct ( df , columns : [ &quot;year&quot; , &quot;country&quot; ] ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 2 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] &gt; If keep_all? is set to true , then the first value of each column not in the requested columns will be returned: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . distinct ( df , columns : [ &quot;year&quot; , &quot;country&quot; ] , keep_all? : true ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , &quot;...&quot; ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , &quot;...&quot; ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , &quot;...&quot; ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , &quot;...&quot; ] cement integer [ 5 , 177 , 2598 , 0 , 204 , &quot;...&quot; ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , &quot;...&quot; ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , &quot;...&quot; ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , &quot;...&quot; ] &gt; A callback on the dataframe's names can be passed instead of a list (like select/3 ): iex&gt; df = Explorer.DataFrame . from_map ( %{ x1 : [ 1 , 3 , 3 ] , x2 : [ &quot;a&quot; , &quot;c&quot; , &quot;c&quot; ] , y1 : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . distinct ( df , columns : &amp; String . starts_with? ( &amp;1 , &quot;x&quot; ) ) # Explorer.DataFrame &lt; [ rows : 2 , columns : 2 ] x1 integer [ 1 , 3 ] x2 string [ &quot;a&quot; , &quot;c&quot; ] &gt;","ref":"Explorer.DataFrame.html#distinct/2","title":"Explorer.DataFrame.distinct/2","type":"function"},{"doc":"Drop nil values. Optionally accepts a subset of columns. Examples iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ 1 , 2 , nil ] , b : [ 1 , nil , 3 ] } ) iex&gt; Explorer.DataFrame . drop_nil ( df ) # Explorer.DataFrame &lt; [ rows : 1 , columns : 2 ] a integer [ 1 ] b integer [ 1 ] &gt;","ref":"Explorer.DataFrame.html#drop_nil/2","title":"Explorer.DataFrame.drop_nil/2","type":"function"},{"doc":"Gets the dtypes of the dataframe columns. Examples iex&gt; df = Explorer.DataFrame . from_map ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , 2 ] } ) iex&gt; Explorer.DataFrame . dtypes ( df ) [ :float , :integer ]","ref":"Explorer.DataFrame.html#dtypes/1","title":"Explorer.DataFrame.dtypes/1","type":"function"},{"doc":"Turns a set of columns to dummy variables. Examples iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; , &quot;c&quot; ] , b : [ &quot;b&quot; , &quot;a&quot; , &quot;b&quot; , &quot;d&quot; ] } ) iex&gt; Explorer.DataFrame . dummies ( df , [ &quot;a&quot; ] ) # Explorer.DataFrame &lt; [ rows : 4 , columns : 3 ] a_a integer [ 1 , 0 , 1 , 0 ] a_b integer [ 0 , 1 , 0 , 0 ] a_c integer [ 0 , 0 , 0 , 1 ] &gt; iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; , &quot;c&quot; ] , b : [ &quot;b&quot; , &quot;a&quot; , &quot;b&quot; , &quot;d&quot; ] } ) iex&gt; Explorer.DataFrame . dummies ( df , [ &quot;a&quot; , &quot;b&quot; ] ) # Explorer.DataFrame &lt; [ rows : 4 , columns : 6 ] a_a integer [ 1 , 0 , 1 , 0 ] a_b integer [ 0 , 1 , 0 , 0 ] a_c integer [ 0 , 0 , 0 , 1 ] b_a integer [ 0 , 1 , 0 , 0 ] b_b integer [ 1 , 0 , 1 , 0 ] b_d integer [ 0 , 0 , 0 , 1 ] &gt;","ref":"Explorer.DataFrame.html#dummies/2","title":"Explorer.DataFrame.dummies/2","type":"function"},{"doc":"Subset rows using column values. Examples You can pass a mask directly: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . filter ( df , Explorer.Series . greater ( df [ &quot;b&quot; ] , 1 ) ) # Explorer.DataFrame &lt; [ rows : 2 , columns : 2 ] a string [ &quot;b&quot; , &quot;c&quot; ] b integer [ 2 , 3 ] &gt; You can combine masks using Explorer.Series.and/2 or Explorer.Series.or/2 : iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; b_gt = Explorer.Series . greater ( df [ &quot;b&quot; ] , 1 ) iex&gt; a_eq = Explorer.Series . equal ( df [ &quot;a&quot; ] , &quot;b&quot; ) iex&gt; Explorer.DataFrame . filter ( df , Explorer.Series . and ( a_eq , b_gt ) ) # Explorer.DataFrame &lt; [ rows : 1 , columns : 2 ] a string [ &quot;b&quot; ] b integer [ 2 ] &gt; Including a list: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . filter ( df , [ false , true , false ] ) # Explorer.DataFrame &lt; [ rows : 1 , columns : 2 ] a string [ &quot;b&quot; ] b integer [ 2 ] &gt; Or you can invoke a callback on the dataframe: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . filter ( df , &amp; Explorer.Series . greater ( &amp;1 [ &quot;b&quot; ] , 1 ) ) # Explorer.DataFrame &lt; [ rows : 2 , columns : 2 ] a string [ &quot;b&quot; , &quot;c&quot; ] b integer [ 2 , 3 ] &gt;","ref":"Explorer.DataFrame.html#filter/2","title":"Explorer.DataFrame.filter/2","type":"function"},{"doc":"Creates a new dataframe from a map of lists. Lists must be the same length. This function calls Explorer.Series.from_list/2 so lists must conform to the requirements for making a series. Options backend - The Explorer backend to use. Defaults to the value returned by Explorer.default_backend/0 . Examples iex&gt; Explorer.DataFrame . from_map ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] } ) # Explorer.DataFrame &lt; [ rows : 2 , columns : 2 ] floats float [ 1.0 , 2.0 ] ints integer [ 1 , nil ] &gt;","ref":"Explorer.DataFrame.html#from_map/2","title":"Explorer.DataFrame.from_map/2","type":"function"},{"doc":"Group the dataframe by one or more variables. When the dataframe has grouping variables, operations are performed per group. Explorer.DataFrame.ungroup/2 removes grouping. Examples You can group by a single variable: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . group_by ( df , &quot;country&quot; ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 10 , groups : [ &quot;country&quot; ] ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , &quot;...&quot; ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , &quot;...&quot; ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , &quot;...&quot; ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , &quot;...&quot; ] cement integer [ 5 , 177 , 2598 , 0 , 204 , &quot;...&quot; ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , &quot;...&quot; ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , &quot;...&quot; ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , &quot;...&quot; ] &gt; Or you can group by multiple: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . group_by ( df , [ &quot;country&quot; , &quot;year&quot; ] ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 10 , groups : [ &quot;country&quot; , &quot;year&quot; ] ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , &quot;...&quot; ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , &quot;...&quot; ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , &quot;...&quot; ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , &quot;...&quot; ] cement integer [ 5 , 177 , 2598 , 0 , 204 , &quot;...&quot; ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , &quot;...&quot; ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , &quot;...&quot; ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , &quot;...&quot; ] &gt;","ref":"Explorer.DataFrame.html#group_by/2","title":"Explorer.DataFrame.group_by/2","type":"function"},{"doc":"Returns the groups of a dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df = Explorer.DataFrame . group_by ( df , &quot;country&quot; ) iex&gt; Explorer.DataFrame . groups ( df ) [ &quot;country&quot; ]","ref":"Explorer.DataFrame.html#groups/1","title":"Explorer.DataFrame.groups/1","type":"function"},{"doc":"Returns the first n rows of the dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . head ( df ) # Explorer.DataFrame &lt; [ rows : 5 , columns : 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 ] cement integer [ 5 , 177 , 2598 , 0 , 204 ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 ] &gt;","ref":"Explorer.DataFrame.html#head/2","title":"Explorer.DataFrame.head/2","type":"function"},{"doc":"Join two tables. Join types inner - Returns all rows from left where there are matching values in right , and all columns from left and right . left - Returns all rows from left and all columns from left and right . Rows in left with no match in right will have nil values in the new columns. right - Returns all rows from right and all columns from left and right . Rows in right with no match in left will have nil values in the new columns. outer - Returns all rows and all columns from both left and right . Where there are not matching values, returns nil for the one missing. cross - Also known as a cartesian join. Returns all combinations of left and right . Can be very computationally expensive. Options on - The columns to join on. Defaults to overlapping columns. Does not apply to cross join. how - One of the join types (as an atom) described above. Defaults to :inner . Examples Inner join: iex&gt; left = Explorer.DataFrame . from_map ( %{ a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] } ) iex&gt; right = Explorer.DataFrame . from_map ( %{ a : [ 1 , 2 , 2 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] } ) iex&gt; Explorer.DataFrame . join ( left , right ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 3 ] a integer [ 1 , 2 , 2 ] b string [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] &gt; Left join: iex&gt; left = Explorer.DataFrame . from_map ( %{ a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] } ) iex&gt; right = Explorer.DataFrame . from_map ( %{ a : [ 1 , 2 , 2 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] } ) iex&gt; Explorer.DataFrame . join ( left , right , how : :left ) # Explorer.DataFrame &lt; [ rows : 4 , columns : 3 ] a integer [ 1 , 2 , 2 , 3 ] b string [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; , &quot;c&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , nil ] &gt; Right join: iex&gt; left = Explorer.DataFrame . from_map ( %{ a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] } ) iex&gt; right = Explorer.DataFrame . from_map ( %{ a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] } ) iex&gt; Explorer.DataFrame . join ( left , right , how : :right ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 3 ] a integer [ 1 , 2 , 4 ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] b string [ &quot;a&quot; , &quot;b&quot; , nil ] &gt; Outer join: iex&gt; left = Explorer.DataFrame . from_map ( %{ a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] } ) iex&gt; right = Explorer.DataFrame . from_map ( %{ a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] } ) iex&gt; Explorer.DataFrame . join ( left , right , how : :outer ) # Explorer.DataFrame &lt; [ rows : 4 , columns : 3 ] b string [ &quot;a&quot; , &quot;b&quot; , nil , &quot;c&quot; ] a integer [ 1 , 2 , 4 , 3 ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , nil ] &gt; Cross join: iex&gt; left = Explorer.DataFrame . from_map ( %{ a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] } ) iex&gt; right = Explorer.DataFrame . from_map ( %{ a : [ 1 , 2 , 4 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] } ) iex&gt; Explorer.DataFrame . join ( left , right , how : :cross ) # Explorer.DataFrame &lt; [ rows : 9 , columns : 4 ] a integer [ 1 , 1 , 1 , 2 , 2 , &quot;...&quot; ] b string [ &quot;a&quot; , &quot;a&quot; , &quot;a&quot; , &quot;b&quot; , &quot;b&quot; , &quot;...&quot; ] a_right integer [ 1 , 2 , 4 , 1 , 2 , &quot;...&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; , &quot;d&quot; , &quot;e&quot; , &quot;...&quot; ] &gt; Inner join with different names: iex&gt; left = Explorer.DataFrame . from_map ( %{ a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] } ) iex&gt; right = Explorer.DataFrame . from_map ( %{ d : [ 1 , 2 , 2 ] , c : [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] } ) iex&gt; Explorer.DataFrame . join ( left , right , on : [ { &quot;a&quot; , &quot;d&quot; } ] ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 3 ] a integer [ 1 , 2 , 2 ] b string [ &quot;a&quot; , &quot;b&quot; , &quot;b&quot; ] c string [ &quot;d&quot; , &quot;e&quot; , &quot;f&quot; ] &gt;","ref":"Explorer.DataFrame.html#join/3","title":"Explorer.DataFrame.join/3","type":"function"},{"doc":"Creates and modifies columns. Columns are added as keyword list arguments. New variables overwrite existing variables of the same name. Column names are coerced from atoms to strings. Examples You can pass in a list directly as a new column: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . mutate ( df , c : [ 4 , 5 , 6 ] ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c integer [ 4 , 5 , 6 ] &gt; Or you can pass in a series: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; s = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.DataFrame . mutate ( df , c : s ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c integer [ 4 , 5 , 6 ] &gt; Or you can invoke a callback on the dataframe: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ 4 , 5 , 6 ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . mutate ( df , c : &amp; Explorer.Series . add ( &amp;1 [ &quot;a&quot; ] , &amp;1 [ &quot;b&quot; ] ) ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 3 ] a integer [ 4 , 5 , 6 ] b integer [ 1 , 2 , 3 ] c integer [ 5 , 7 , 9 ] &gt; You can overwrite existing columns: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . mutate ( df , a : [ 4 , 5 , 6 ] ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] a integer [ 4 , 5 , 6 ] b integer [ 1 , 2 , 3 ] &gt; Scalar values are repeated to fill the series: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . mutate ( df , a : 4 ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] a integer [ 4 , 4 , 4 ] b integer [ 1 , 2 , 3 ] &gt; Including when a callback returns a scalar: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . mutate ( df , a : &amp; Explorer.Series . max ( &amp;1 [ &quot;b&quot; ] ) ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] a integer [ 3 , 3 , 3 ] b integer [ 1 , 2 , 3 ] &gt; Alternatively, all of the above works with a map instead of a keyword list: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . mutate ( df , %{ &quot;c&quot; =&gt; [ 4 , 5 , 6 ] } ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 3 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] b integer [ 1 , 2 , 3 ] c integer [ 4 , 5 , 6 ] &gt;","ref":"Explorer.DataFrame.html#mutate/2","title":"Explorer.DataFrame.mutate/2","type":"function"},{"doc":"Returns the number of columns in the dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . n_cols ( df ) 10","ref":"Explorer.DataFrame.html#n_cols/1","title":"Explorer.DataFrame.n_cols/1","type":"function"},{"doc":"Returns the number of rows in the dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . n_rows ( df ) 1094","ref":"Explorer.DataFrame.html#n_rows/1","title":"Explorer.DataFrame.n_rows/1","type":"function"},{"doc":"Gets the names of the dataframe columns. Examples iex&gt; df = Explorer.DataFrame . from_map ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , 2 ] } ) iex&gt; Explorer.DataFrame . names ( df ) [ &quot;floats&quot; , &quot;ints&quot; ]","ref":"Explorer.DataFrame.html#names/1","title":"Explorer.DataFrame.names/1","type":"function"},{"doc":"Pivot data from wide to long. Explorer.DataFrame.pivot_longer/3 &quot;lengthens&quot; data, increasing the number of rows and decreasing the number of columns. The inverse transformation is Explorer.DataFrame.pivot_wider/4 . The second argument ( columns ) can be either an array of column names to use or a filter callback on the dataframe's names. value_cols must all have the same dtype. Options value_cols - Columns to use for values. May be a filter callback on the dataframe's column names. Defaults to an empty list, using all variables except the columns to pivot. names_to - A string specifying the name of the column to create from the data stored in the column names of the dataframe. Defaults to &quot;variable&quot; . values_to - A string specifying the name of the column to create from the data stored in series element values. Defaults to &quot;value&quot; . Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pivot_longer ( df , [ &quot;year&quot; , &quot;country&quot; ] , value_cols : &amp; String . ends_with? ( &amp;1 , &quot;fuel&quot; ) ) # Explorer.DataFrame &lt; [ rows : 3282 , columns : 4 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] variable string [ &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;solid_fuel&quot; , &quot;...&quot; ] value integer [ 627 , 117 , 332 , 0 , 0 , &quot;...&quot; ] &gt; iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pivot_longer ( df , [ &quot;year&quot; , &quot;country&quot; ] , value_cols : [ &quot;total&quot; ] ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 4 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] variable string [ &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , &quot;total&quot; , &quot;...&quot; ] value integer [ 2308 , 1254 , 32500 , 141 , 7924 , &quot;...&quot; ] &gt;","ref":"Explorer.DataFrame.html#pivot_longer/3","title":"Explorer.DataFrame.pivot_longer/3","type":"function"},{"doc":"Pivot data from long to wide. Explorer.DataFrame.pivot_wider/4 &quot;widens&quot; data, increasing the number of columns and decreasing the number of rows. The inverse transformation is Explorer.DataFrame.pivot_longer/3 . Due to a restriction upstream, values_from must be a numeric type. Options id_cols - A set of columns that uniquely identifies each observation. Defaults to all columns in data except for the columns specified in names_from and values_from . Typically used when you have redundant variables, i.e. variables whose values are perfectly correlated with existing variables. May accept a filter callback or list of column names. names_prefix - String added to the start of every variable name. This is particularly useful if names_from is a numeric vector and you want to create syntactic variable names.","ref":"Explorer.DataFrame.html#pivot_wider/4","title":"Explorer.DataFrame.pivot_wider/4","type":"function"},{"doc":"Extracts a single column as a series. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . pull ( df , &quot;total&quot; ) # Explorer.Series &lt; integer [ 1094 ] [ 2308 , 1254 , 32500 , 141 , 7924 , 41 , 143 , 51246 , 1150 , 684 , 106589 , 18408 , 8366 , 451 , 7981 , 16345 , 403 , 17192 , 30222 , 147 , 1388 , 166 , 133 , 5802 , 1278 , 114468 , 47 , 2237 , 12030 , 535 , 58 , 1367 , 145806 , 152 , 152 , 72 , 141 , 19703 , 2393248 , 20773 , 44 , 540 , 19 , 2064 , 1900 , 5501 , 10465 , 2102 , 30428 , 18122 , ... ] &gt;","ref":"Explorer.DataFrame.html#pull/2","title":"Explorer.DataFrame.pull/2","type":"function"},{"doc":"Reads a delimited file into a dataframe. Options delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) dtypes - A list of {&quot;column_name&quot;, dtype} tuples. Uses column names as read, not as defined in options. If nil , dtypes are imputed from the first 1000 rows. (default: nil ) header? - Does the file have a header of column names as the first row or not? (default: true ) max_rows - Maximum number of lines to read. (default: Inf ) names - A list of column names. Must match the width of the dataframe. (default: nil) null_character - The string that should be interpreted as a nil value. (default: &quot;NA&quot; ) skip_rows - The number of lines to skip at the beginning of the file. (default: 0 ) with_columns - A list of column names to keep. If present, only these columns are read into the dataframe. (default: nil ) infer_schema_length Maximum number of rows read for schema inference. Setting this to nil will do a full table scan and will be slow (default: 1000 ). parse_dates - Automatically try to parse dates/ datetimes and time. If parsing fails, columns remain of dtype [DataType::Utf8]","ref":"Explorer.DataFrame.html#read_csv/2","title":"Explorer.DataFrame.read_csv/2","type":"function"},{"doc":"Similar to read_csv/2 but raises if there is a problem reading the CSV.","ref":"Explorer.DataFrame.html#read_csv!/2","title":"Explorer.DataFrame.read_csv!/2","type":"function"},{"doc":"Reads a parquet file into a dataframe.","ref":"Explorer.DataFrame.html#read_parquet/1","title":"Explorer.DataFrame.read_parquet/1","type":"function"},{"doc":"Renames columns. To apply a function to a subset of columns, see rename_with/3 . Examples You can pass in a list of new names: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] } ) iex&gt; Explorer.DataFrame . rename ( df , [ &quot;c&quot; , &quot;d&quot; ] ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] c string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] d integer [ 1 , 3 , 1 ] &gt; Or you can rename individual columns using keyword args: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] } ) iex&gt; Explorer.DataFrame . rename ( df , a : &quot;first&quot; ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] first string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 1 , 3 , 1 ] &gt; Or you can rename individual columns using a map: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] } ) iex&gt; Explorer.DataFrame . rename ( df , %{ &quot;a&quot; =&gt; &quot;first&quot; } ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] first string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] b integer [ 1 , 3 , 1 ] &gt; Or if you want to use a function: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] , b : [ 1 , 3 , 1 ] } ) iex&gt; Explorer.DataFrame . rename ( df , &amp; ( &amp;1 &lt;&gt; &quot;_test&quot; ) ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] a_test string [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; ] b_test integer [ 1 , 3 , 1 ] &gt;","ref":"Explorer.DataFrame.html#rename/2","title":"Explorer.DataFrame.rename/2","type":"function"},{"doc":"Renames columns with a function. Examples If no columns are specified, it will apply the function to all column names: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , &amp; String . upcase / 1 ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 10 ] YEAR integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] COUNTRY string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] TOTAL integer [ 2308 , 1254 , 32500 , 141 , 7924 , &quot;...&quot; ] SOLID_FUEL integer [ 627 , 117 , 332 , 0 , 0 , &quot;...&quot; ] LIQUID_FUEL integer [ 1601 , 953 , 12381 , 141 , 3649 , &quot;...&quot; ] GAS_FUEL integer [ 74 , 7 , 14565 , 0 , 374 , &quot;...&quot; ] CEMENT integer [ 5 , 177 , 2598 , 0 , 204 , &quot;...&quot; ] GAS_FLARING integer [ 0 , 0 , 2623 , 0 , 3697 , &quot;...&quot; ] PER_CAPITA float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , &quot;...&quot; ] BUNKER_FUELS integer [ 9 , 7 , 663 , 0 , 321 , &quot;...&quot; ] &gt; A callback can be used to filter the column names that will be renamed, similarly to select/3 : iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , &amp; String . trim_trailing ( &amp;1 , &quot;_fuel&quot; ) , &amp; String . ends_with? ( &amp;1 , &quot;_fuel&quot; ) ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , &quot;...&quot; ] solid integer [ 627 , 117 , 332 , 0 , 0 , &quot;...&quot; ] liquid integer [ 1601 , 953 , 12381 , 141 , 3649 , &quot;...&quot; ] gas integer [ 74 , 7 , 14565 , 0 , 374 , &quot;...&quot; ] cement integer [ 5 , 177 , 2598 , 0 , 204 , &quot;...&quot; ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , &quot;...&quot; ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , &quot;...&quot; ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , &quot;...&quot; ] &gt; Or you can just pass in the list of column names you'd like to apply the function to: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . rename_with ( df , &amp; String . upcase / 1 , [ &quot;total&quot; , &quot;cement&quot; ] ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 10 ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] TOTAL integer [ 2308 , 1254 , 32500 , 141 , 7924 , &quot;...&quot; ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , &quot;...&quot; ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , &quot;...&quot; ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , &quot;...&quot; ] CEMENT integer [ 5 , 177 , 2598 , 0 , 204 , &quot;...&quot; ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , &quot;...&quot; ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , &quot;...&quot; ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , &quot;...&quot; ] &gt;","ref":"Explorer.DataFrame.html#rename_with/3","title":"Explorer.DataFrame.rename_with/3","type":"function"},{"doc":"Sample rows from a dataframe. If given an integer as the second argument, it will return N samples. If given a float, it will return that proportion of the series. Can sample with or without replacement. Options with_replacement? - If set to true , each sample will be independent and therefore values may repeat. Required to be true for n greater then the number of rows in the dataframe or frac &gt; 1.0. (default: false ) seed - An integer to be used as a random seed. If nil, a random value between 1 and 1e12 will be used. (default: nil) Examples You can sample N rows: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . sample ( df , 3 , seed : 100 ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 10 ] year integer [ 2012 , 2012 , 2013 ] country string [ &quot;ZIMBABWE&quot; , &quot;NICARAGUA&quot; , &quot;NIGER&quot; ] total integer [ 2125 , 1260 , 529 ] solid_fuel integer [ 917 , 0 , 93 ] liquid_fuel integer [ 1006 , 1176 , 432 ] gas_fuel integer [ 0 , 0 , 0 ] cement integer [ 201 , 84 , 4 ] gas_flaring integer [ 0 , 0 , 0 ] per_capita float [ 0.15 , 0.21 , 0.03 ] bunker_fuels integer [ 9 , 18 , 19 ] &gt; Or you can sample a proportion of rows: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . sample ( df , 0.03 , seed : 100 ) # Explorer.DataFrame &lt; [ rows : 33 , columns : 10 ] year integer [ 2013 , 2012 , 2013 , 2012 , 2010 , &quot;...&quot; ] country string [ &quot;BAHAMAS&quot; , &quot;POLAND&quot; , &quot;SLOVAKIA&quot; , &quot;MOZAMBIQUE&quot; , &quot;OMAN&quot; , &quot;...&quot; ] total integer [ 764 , 81792 , 9024 , 851 , 12931 , &quot;...&quot; ] solid_fuel integer [ 1 , 53724 , 3657 , 11 , 0 , &quot;...&quot; ] liquid_fuel integer [ 763 , 17353 , 2090 , 632 , 2331 , &quot;...&quot; ] gas_fuel integer [ 0 , 8544 , 2847 , 47 , 9309 , &quot;...&quot; ] cement integer [ 0 , 2165 , 424 , 161 , 612 , &quot;...&quot; ] gas_flaring integer [ 0 , 6 , 7 , 0 , 679 , &quot;...&quot; ] per_capita float [ 2.02 , 2.12 , 1.67 , 0.03 , 4.39 , &quot;...&quot; ] bunker_fuels integer [ 167 , 573 , 34 , 56 , 1342 , &quot;...&quot; ] &gt;","ref":"Explorer.DataFrame.html#sample/3","title":"Explorer.DataFrame.sample/3","type":"function"},{"doc":"Selects a subset of columns by name. Can optionally return all but the named columns if :drop is passed as the last argument. Examples You can select columns with a list of names: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . select ( df , [ &quot;a&quot; ] ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 1 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] &gt; Or you can use a callback function that takes the dataframe's names as its first argument: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . select ( df , &amp; String . starts_with? ( &amp;1 , &quot;b&quot; ) ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 1 ] b integer [ 1 , 2 , 3 ] &gt; If you pass :drop as the third argument, it will return all but the named columns: iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . select ( df , [ &quot;b&quot; ] , :drop ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 1 ] a string [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] &gt; iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] , b : [ 1 , 2 , 3 ] , c : [ 4 , 5 , 6 ] } ) iex&gt; Explorer.DataFrame . select ( df , [ &quot;a&quot; , &quot;b&quot; ] , :drop ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 1 ] c integer [ 4 , 5 , 6 ] &gt;","ref":"Explorer.DataFrame.html#select/3","title":"Explorer.DataFrame.select/3","type":"function"},{"doc":"Gets the shape of the dataframe as a {height, width} tuple. Examples iex&gt; df = Explorer.DataFrame . from_map ( %{ floats : [ 1.0 , 2.0 , 3.0 ] , ints : [ 1 , 2 , 3 ] } ) iex&gt; Explorer.DataFrame . shape ( df ) { 3 , 2 }","ref":"Explorer.DataFrame.html#shape/1","title":"Explorer.DataFrame.shape/1","type":"function"},{"doc":"Subset a continuous set of rows. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . slice ( df , 1 , 2 ) # Explorer.DataFrame &lt; [ rows : 2 , columns : 10 ] year integer [ 2010 , 2010 ] country string [ &quot;ALBANIA&quot; , &quot;ALGERIA&quot; ] total integer [ 1254 , 32500 ] solid_fuel integer [ 117 , 332 ] liquid_fuel integer [ 953 , 12381 ] gas_fuel integer [ 7 , 14565 ] cement integer [ 177 , 2598 ] gas_flaring integer [ 0 , 2623 ] per_capita float [ 0.43 , 0.9 ] bunker_fuels integer [ 7 , 663 ] &gt; Negative offsets count from the end of the series: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . slice ( df , - 10 , 2 ) # Explorer.DataFrame &lt; [ rows : 2 , columns : 10 ] year integer [ 2014 , 2014 ] country string [ &quot;UNITED STATES OF AMERICA&quot; , &quot;URUGUAY&quot; ] total integer [ 1432855 , 1840 ] solid_fuel integer [ 450047 , 2 ] liquid_fuel integer [ 576531 , 1700 ] gas_fuel integer [ 390719 , 25 ] cement integer [ 11314 , 112 ] gas_flaring integer [ 4244 , 0 ] per_capita float [ 4.43 , 0.54 ] bunker_fuels integer [ 30722 , 251 ] &gt; If the length would run past the end of the dataframe, the result may be shorter than the length: iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . slice ( df , - 10 , 20 ) # Explorer.DataFrame &lt; [ rows : 10 , columns : 10 ] year integer [ 2014 , 2014 , 2014 , 2014 , 2014 , &quot;...&quot; ] country string [ &quot;UNITED STATES OF AMERICA&quot; , &quot;URUGUAY&quot; , &quot;UZBEKISTAN&quot; , &quot;VANUATU&quot; , &quot;VENEZUELA&quot; , &quot;...&quot; ] total integer [ 1432855 , 1840 , 28692 , 42 , 50510 , &quot;...&quot; ] solid_fuel integer [ 450047 , 2 , 1677 , 0 , 204 , &quot;...&quot; ] liquid_fuel integer [ 576531 , 1700 , 2086 , 42 , 28445 , &quot;...&quot; ] gas_fuel integer [ 390719 , 25 , 23929 , 0 , 12731 , &quot;...&quot; ] cement integer [ 11314 , 112 , 1000 , 0 , 1088 , &quot;...&quot; ] gas_flaring integer [ 4244 , 0 , 0 , 0 , 8042 , &quot;...&quot; ] per_capita float [ 4.43 , 0.54 , 0.97 , 0.16 , 1.65 , &quot;...&quot; ] bunker_fuels integer [ 30722 , 251 , 0 , 10 , 1256 , &quot;...&quot; ] &gt;","ref":"Explorer.DataFrame.html#slice/3","title":"Explorer.DataFrame.slice/3","type":"function"},{"doc":"Summarise each group to a single row. Implicitly ungroups. Supported operations The following aggregations may be performed: :min - Take the minimum value within the group. See Explorer.Series.min/1 . :max - Take the maximum value within the group. See Explorer.Series.max/1 . :sum - Take the sum of the series within the group. See Explorer.Series.sum/1 . :mean - Take the mean of the series within the group. See Explorer.Series.mean/1 . :median - Take the median of the series within the group. See Explorer.Series.median/1 . :first - Take the first value within the group. See Explorer.Series.first/1 . :last - Take the last value within the group. See Explorer.Series.last/1 . :count - Count the number of rows per group. :n_unique - Count the number of unique rows per group. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df |&gt; Explorer.DataFrame . group_by ( &quot;year&quot; ) |&gt; Explorer.DataFrame . summarise ( total : [ :max , :min ] , country : [ :n_unique ] ) # Explorer.DataFrame &lt; [ rows : 5 , columns : 4 ] year integer [ 2010 , 2011 , 2012 , 2013 , 2014 ] country_n_unique integer [ 217 , 217 , 220 , 220 , 220 ] total_max integer [ 2393248 , 2654360 , 2734817 , 2797384 , 2806634 ] total_min integer [ 1 , 2 , 2 , 2 , 3 ] &gt;","ref":"Explorer.DataFrame.html#summarise/2","title":"Explorer.DataFrame.summarise/2","type":"function"},{"doc":"Display the DataFrame in a tabular fashion. ## Examples df = Explorer.Datasets . iris ( ) Explorer.DataFrame . table ( df )","ref":"Explorer.DataFrame.html#table/2","title":"Explorer.DataFrame.table/2","type":"function"},{"doc":"Returns the last n rows of the dataframe. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; Explorer.DataFrame . tail ( df ) # Explorer.DataFrame &lt; [ rows : 5 , columns : 10 ] year integer [ 2014 , 2014 , 2014 , 2014 , 2014 ] country string [ &quot;VIET NAM&quot; , &quot;WALLIS AND FUTUNA ISLANDS&quot; , &quot;YEMEN&quot; , &quot;ZAMBIA&quot; , &quot;ZIMBABWE&quot; ] total integer [ 45517 , 6 , 6190 , 1228 , 3278 ] solid_fuel integer [ 19246 , 0 , 137 , 132 , 2097 ] liquid_fuel integer [ 12694 , 6 , 5090 , 797 , 1005 ] gas_fuel integer [ 5349 , 0 , 581 , 0 , 0 ] cement integer [ 8229 , 0 , 381 , 299 , 177 ] gas_flaring integer [ 0 , 0 , 0 , 0 , 0 ] per_capita float [ 0.49 , 0.44 , 0.24 , 0.08 , 0.22 ] bunker_fuels integer [ 761 , 1 , 153 , 33 , 9 ] &gt;","ref":"Explorer.DataFrame.html#tail/2","title":"Explorer.DataFrame.tail/2","type":"function"},{"doc":"Subset rows with a list of indices. Examples iex&gt; df = Explorer.DataFrame . from_map ( %{ a : [ 1 , 2 , 3 ] , b : [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] } ) iex&gt; Explorer.DataFrame . take ( df , [ 0 , 2 ] ) # Explorer.DataFrame &lt; [ rows : 2 , columns : 2 ] a integer [ 1 , 3 ] b string [ &quot;a&quot; , &quot;c&quot; ] &gt;","ref":"Explorer.DataFrame.html#take/2","title":"Explorer.DataFrame.take/2","type":"function"},{"doc":"Writes a dataframe to a binary representation of a delimited file. Options header? - Should the column names be written as the first line of the file? (default: true ) delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; ) Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df |&gt; Explorer.DataFrame . head ( ) |&gt; Explorer.DataFrame . to_binary ( ) &quot;year,country,total,solid_fuel,liquid_fuel,gas_fuel,cement,gas_flaring,per_capita,bunker_fuels \\n 2010,AFGHANISTAN,2308,627,1601,74,5,0,0.08,9 \\n 2010,ALBANIA,1254,117,953,7,177,0,0.43,7 \\n 2010,ALGERIA,32500,332,12381,14565,2598,2623,0.9,663 \\n 2010,ANDORRA,141,0,141,0,0,0,1.68,0 \\n 2010,ANGOLA,7924,0,3649,374,204,3697,0.37,321 \\n &quot;","ref":"Explorer.DataFrame.html#to_binary/2","title":"Explorer.DataFrame.to_binary/2","type":"function"},{"doc":"Converts a dataframe to a map. By default, the constituent series of the dataframe are converted to Elixir lists. Examples iex&gt; df = Explorer.DataFrame . from_map ( %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] } ) iex&gt; Explorer.DataFrame . to_map ( df ) %{ floats : [ 1.0 , 2.0 ] , ints : [ 1 , nil ] }","ref":"Explorer.DataFrame.html#to_map/2","title":"Explorer.DataFrame.to_map/2","type":"function"},{"doc":"Removes grouping variables. Examples iex&gt; df = Explorer.Datasets . fossil_fuels ( ) iex&gt; df = Explorer.DataFrame . group_by ( df , [ &quot;country&quot; , &quot;year&quot; ] ) iex&gt; Explorer.DataFrame . ungroup ( df , [ &quot;country&quot; ] ) # Explorer.DataFrame &lt; [ rows : 1094 , columns : 10 , groups : [ &quot;year&quot; ] ] year integer [ 2010 , 2010 , 2010 , 2010 , 2010 , &quot;...&quot; ] country string [ &quot;AFGHANISTAN&quot; , &quot;ALBANIA&quot; , &quot;ALGERIA&quot; , &quot;ANDORRA&quot; , &quot;ANGOLA&quot; , &quot;...&quot; ] total integer [ 2308 , 1254 , 32500 , 141 , 7924 , &quot;...&quot; ] solid_fuel integer [ 627 , 117 , 332 , 0 , 0 , &quot;...&quot; ] liquid_fuel integer [ 1601 , 953 , 12381 , 141 , 3649 , &quot;...&quot; ] gas_fuel integer [ 74 , 7 , 14565 , 0 , 374 , &quot;...&quot; ] cement integer [ 5 , 177 , 2598 , 0 , 204 , &quot;...&quot; ] gas_flaring integer [ 0 , 0 , 2623 , 0 , 3697 , &quot;...&quot; ] per_capita float [ 0.08 , 0.43 , 0.9 , 1.68 , 0.37 , &quot;...&quot; ] bunker_fuels integer [ 9 , 7 , 663 , 0 , 321 , &quot;...&quot; ] &gt;","ref":"Explorer.DataFrame.html#ungroup/2","title":"Explorer.DataFrame.ungroup/2","type":"function"},{"doc":"Writes a dataframe to a delimited file. Options header? - Should the column names be written as the first line of the file? (default: true ) delimiter - A single character used to separate fields within a record. (default: &quot;,&quot; )","ref":"Explorer.DataFrame.html#write_csv/3","title":"Explorer.DataFrame.write_csv/3","type":"function"},{"doc":"Similar to write_csv/3 but raises if there is a problem reading the CSV.","ref":"Explorer.DataFrame.html#write_csv!/3","title":"Explorer.DataFrame.write_csv!/3","type":"function"},{"doc":"Writes a dataframe to a parquet file.","ref":"Explorer.DataFrame.html#write_parquet/2","title":"Explorer.DataFrame.write_parquet/2","type":"function"},{"doc":"","ref":"Explorer.DataFrame.html#t:data/0","title":"Explorer.DataFrame.data/0","type":"type"},{"doc":"","ref":"Explorer.DataFrame.html#t:t/0","title":"Explorer.DataFrame.t/0","type":"type"},{"doc":"","ref":"Explorer.Datasets.html","title":"Explorer.Datasets","type":"module"},{"doc":"CO2 emissions from fossil fuels since 2010, by country Citation Boden, T.A., G. Marland, and R.J. Andres. 2013. Global, Regional, and National Fossil-Fuel CO2 Emissions. Carbon Dioxide Information Analysis Center, Oak Ridge National Laboratory, U.S. Department of Energy, Oak Ridge, Tenn., U.S.A. doi 10.3334/CDIAC/00001_V2013","ref":"Explorer.Datasets.html#fossil_fuels/0","title":"Explorer.Datasets.fossil_fuels/0","type":"function"},{"doc":"Iris Dataset - This classic dataset was collected by Edgar Anderson in 1936 and made famous by R. A. Fisher's 1936 paper. It consists of several measurements of three species of Iris (Iris setosa, Iris virginica and Iris versicolor). Downloaded and modified from: https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data Citation Original Owners: R. A. Fisher (1936) The use of multiple measurements in taxonomic problems. Annals of Eugenics. 7 (2): 179–188. doi:10.1111/j.1469-1809.1936.tb02137.x Iris. (1936). UCI Machine Learning Repository.","ref":"Explorer.Datasets.html#iris/0","title":"Explorer.Datasets.iris/0","type":"function"},{"doc":"Wine Dataset - The data is the result of a chemical analysis of wines grown in the same region in Italy but derived from three different cultivars. The analysis determined the quantities of 13 constituents found in each of the three types of wines. Downloaded and modified from: https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data Citation Original Owners: Forina, M. et al, PARVUS - An Extendible Package for Data Exploration, Classification and Correlation. Institute of Pharmaceutical and Food Analysis and Technologies, Via Brigata Salerno, 16147 Genoa, Italy. Wine. (1991). UCI Machine Learning Repository.","ref":"Explorer.Datasets.html#wine/0","title":"Explorer.Datasets.wine/0","type":"function"},{"doc":"The Series struct and API. A series can be of the following data types: :float - 64-bit floating point number :integer - 64-bit signed integer :boolean - Boolean :string - UTF-8 encoded binary :date - Date type that unwraps to Elixir.Date :datetime - DateTime type that unwraps to Elixir.NaiveDateTime A series must consist of a single data type only. Series are nullable, but may not consist only of nils. Many functions only apply to certain dtypes. Where that is the case, you'll find a Supported dtypes section in the function documentation and the function will raise an ArgumentError if a series with an invalid dtype is used.","ref":"Explorer.Series.html","title":"Explorer.Series","type":"module"},{"doc":"Adds right to left, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.Series . add ( s1 , s2 ) # Explorer.Series &lt; integer [ 3 ] [ 5 , 7 , 9 ] &gt;","ref":"Explorer.Series.html#add/2","title":"Explorer.Series.add/2","type":"function"},{"doc":"Checks equality between two entire series. Examples iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; Explorer.Series . all_equal? ( s1 , s2 ) true iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . all_equal? ( s1 , s2 ) false iex&gt; s1 = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 ] ) iex&gt; Explorer.Series . all_equal? ( s1 , s2 ) false","ref":"Explorer.Series.html#all_equal?/2","title":"Explorer.Series.all_equal?/2","type":"function"},{"doc":"Returns a boolean mask of left and right , element-wise Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; mask1 = Explorer.Series . greater ( s1 , 1 ) iex&gt; mask2 = Explorer.Series . less ( s1 , 3 ) iex&gt; Explorer.Series . and ( mask1 , mask2 ) # Explorer.Series &lt; boolean [ 3 ] [ false , true , false ] &gt;","ref":"Explorer.Series.html#and/2","title":"Explorer.Series.and/2","type":"function"},{"doc":"Returns the indices that would sort the series.","ref":"Explorer.Series.html#argsort/2","title":"Explorer.Series.argsort/2","type":"function"},{"doc":"Cast the series to another type. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :string ) # Explorer.Series &lt; string [ 3 ] [ &quot;1&quot; , &quot;2&quot; , &quot;3&quot; ] &gt; cast/2 will return the series as a no-op if you try to cast to the same dtype. iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . cast ( s , :integer ) # Explorer.Series &lt; integer [ 3 ] [ 1 , 2 , 3 ] &gt;","ref":"Explorer.Series.html#cast/2","title":"Explorer.Series.cast/2","type":"function"},{"doc":"Concatenate one or more series. The dtypes must match unless all are numeric, in which case all series will be downcast to float. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.Series . concat ( [ s1 , s2 ] ) # Explorer.Series &lt; integer [ 6 ] [ 1 , 2 , 3 , 4 , 5 , 6 ] &gt; iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4.0 , 5.0 , 6.4 ] ) iex&gt; Explorer.Series . concat ( s1 , s2 ) # Explorer.Series &lt; float [ 6 ] [ 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.4 ] &gt;","ref":"Explorer.Series.html#concat/1","title":"Explorer.Series.concat/1","type":"function"},{"doc":"Concatenate one or more series. concat(s1, s2) is equivalent to concat([s1, s2]) .","ref":"Explorer.Series.html#concat/2","title":"Explorer.Series.concat/2","type":"function"},{"doc":"Creates a new dataframe with unique values and the count of each. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;c&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . count ( s ) # Explorer.DataFrame &lt; [ rows : 3 , columns : 2 ] values string [ &quot;c&quot; , &quot;a&quot; , &quot;b&quot; ] counts integer [ 3 , 2 , 1 ] &gt;","ref":"Explorer.Series.html#count/1","title":"Explorer.Series.count/1","type":"function"},{"doc":"Calculates the cumulative maximum of the series. Optionally, can fill in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :date :datetime Examples iex&gt; s = [ 1 , 2 , 3 , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cum_max ( s ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 3 , 4 ] &gt; iex&gt; s = [ 1 , 2 , nil , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cum_max ( s ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , nil , 4 ] &gt;","ref":"Explorer.Series.html#cum_max/2","title":"Explorer.Series.cum_max/2","type":"function"},{"doc":"Calculates the cumulative minimum of the series. Optionally, can fill in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :date :datetime Examples iex&gt; s = [ 1 , 2 , 3 , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cum_min ( s ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 1 , 1 , 1 ] &gt; iex&gt; s = [ 1 , 2 , nil , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cum_min ( s ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 1 , nil , 1 ] &gt;","ref":"Explorer.Series.html#cum_min/2","title":"Explorer.Series.cum_min/2","type":"function"},{"doc":"Calculates the cumulative sum of the series. Optionally, can fill in reverse. Does not fill nil values. See fill_missing/2 . Supported dtypes :integer :float :boolean Examples iex&gt; s = [ 1 , 2 , 3 , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cum_sum ( s ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 3 , 6 , 10 ] &gt; iex&gt; s = [ 1 , 2 , nil , 4 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . cum_sum ( s ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 3 , nil , 7 ] &gt;","ref":"Explorer.Series.html#cum_sum/2","title":"Explorer.Series.cum_sum/2","type":"function"},{"doc":"Returns the unique values of the series. Examples iex&gt; s = [ 1 , 1 , 2 , 2 , 3 , 3 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . distinct ( ) # Explorer.Series &lt; integer [ 3 ] [ 1 , 2 , 3 ] &gt;","ref":"Explorer.Series.html#distinct/1","title":"Explorer.Series.distinct/1","type":"function"},{"doc":"Divides left by right, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float Examples iex&gt; s1 = [ 10 , 10 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = [ 2 , 2 , 2 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . divide ( s1 , s2 ) # Explorer.Series &lt; integer [ 3 ] [ 5 , 5 , 5 ] &gt; iex&gt; s1 = [ 10 , 10 , 10 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . divide ( s1 , 2 ) # Explorer.Series &lt; integer [ 3 ] [ 5 , 5 , 5 ] &gt;","ref":"Explorer.Series.html#divide/2","title":"Explorer.Series.divide/2","type":"function"},{"doc":"Returns the data type of the series. A series can be of the following data types: :float - 64-bit floating point number :integer - 64-bit signed integer :boolean - Boolean :string - UTF-8 encoded binary :date - Date type that unwraps to Elixir.Date :datetime - DateTime type that unwraps to Elixir.NaiveDateTime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . dtype ( s ) :integer iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , nil , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . dtype ( s ) :string","ref":"Explorer.Series.html#dtype/1","title":"Explorer.Series.dtype/1","type":"function"},{"doc":"Returns boolean mask of left == right , element-wise. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . equal ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ true , true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . equal ( s , 1 ) # Explorer.Series &lt; boolean [ 3 ] [ true , false , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ true , true , false ] ) iex&gt; Explorer.Series . equal ( s , true ) # Explorer.Series &lt; boolean [ 3 ] [ true , true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . equal ( s , &quot;a&quot; ) # Explorer.Series &lt; boolean [ 3 ] [ true , false , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . equal ( s , ~D[1999-12-31] ) # Explorer.Series &lt; boolean [ 2 ] [ false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~N[2022-01-01 00:00:00] , ~N[2022-01-01 23:00:00] ] ) iex&gt; Explorer.Series . equal ( s , ~N[2022-01-01 00:00:00] ) # Explorer.Series &lt; boolean [ 2 ] [ true , false ] &gt;","ref":"Explorer.Series.html#equal/2","title":"Explorer.Series.equal/2","type":"function"},{"doc":"Fill missing values with the given strategy. If a scalar value is provided instead of a strategy atom, nil will be replaced with that value. It must be of the same dtype as the series. Strategies :forward - replace nil with the previous value :backward - replace nil with the next value :max - replace nil with the series maximum :min - replace nil with the series minimum :mean - replace nil with the series mean Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :forward ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 2 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :backward ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 4 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :max ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 4 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :min ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 1 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , :mean ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 2 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . fill_missing ( s , 3 ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 2 , 3 , 4 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 4.0 ] ) iex&gt; Explorer.Series . fill_missing ( s , 3.0 ) # Explorer.Series &lt; float [ 4 ] [ 1.0 , 2.0 , 3.0 , 4.0 ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , nil , &quot;d&quot; ] ) iex&gt; Explorer.Series . fill_missing ( s , &quot;c&quot; ) # Explorer.Series &lt; string [ 4 ] [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;d&quot; ] &gt;","ref":"Explorer.Series.html#fill_missing/2","title":"Explorer.Series.fill_missing/2","type":"function"},{"doc":"Filters a series with a mask or callback. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . filter ( s1 , s2 ) # Explorer.Series &lt; integer [ 2 ] [ 1 , 3 ] &gt; iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 1 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 ] ) iex&gt; Explorer.Series . filter ( s1 , &amp; Explorer.Series . equal ( &amp;1 , s2 ) ) # Explorer.Series &lt; integer [ 2 ] [ 1 , 1 ] &gt;","ref":"Explorer.Series.html#filter/2","title":"Explorer.Series.filter/2","type":"function"},{"doc":"Returns the first element of the series. ## Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . first ( s ) 1","ref":"Explorer.Series.html#first/1","title":"Explorer.Series.first/1","type":"function"},{"doc":"Creates a new series from a list. The list must consist of a single data type and nils only; however, the list may not only consist of nils. Options :backend - The backend to allocate the series on. Examples Explorer will infer the type from the values in the list. iex&gt; Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) # Explorer.Series &lt; integer [ 3 ] [ 1 , 2 , 3 ] &gt; Series are nullable, so you may also include nils. iex&gt; Explorer.Series . from_list ( [ 1.0 , nil , 2.5 , 3.1 ] ) # Explorer.Series &lt; float [ 4 ] [ 1.0 , nil , 2.5 , 3.1 ] &gt; A mix of integers and floats will be downcasted to a float. iex&gt; Explorer.Series . from_list ( [ 1 , 2.0 ] ) # Explorer.Series &lt; float [ 2 ] [ 1.0 , 2.0 ] &gt; Mixing non-numeric data types will raise an ArgumentError. iex&gt; Explorer.Series . from_list ( [ 1 , &quot;a&quot; ] ) ** (ArgumentError) cannot make a series from mismatched types: type of &quot;a&quot; does not match inferred dtype integer","ref":"Explorer.Series.html#from_list/2","title":"Explorer.Series.from_list/2","type":"function"},{"doc":"Converts a Nx.Tensor.t/0 to a series. Examples iex&gt; tensor = Nx . tensor ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . from_tensor ( tensor ) # Explorer.Series &lt; integer [ 3 ] [ 1 , 2 , 3 ] &gt; iex&gt; tensor = Nx . tensor ( [ 1.0 , 2.0 , 3.0 ] ) iex&gt; Explorer.Series . from_tensor ( tensor ) # Explorer.Series &lt; float [ 3 ] [ 1.0 , 2.0 , 3.0 ] &gt;","ref":"Explorer.Series.html#from_tensor/2","title":"Explorer.Series.from_tensor/2","type":"function"},{"doc":"Returns the value of the series at the given index. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . get ( s , 2 ) &quot;c&quot; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . get ( s , 4 ) ** (ArgumentError) index 4 out of bounds for series of length 3","ref":"Explorer.Series.html#get/2","title":"Explorer.Series.get/2","type":"function"},{"doc":"Returns boolean mask of left &gt; right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . greater ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ false , false , false ] &gt;","ref":"Explorer.Series.html#greater/2","title":"Explorer.Series.greater/2","type":"function"},{"doc":"Returns boolean mask of left &gt;= right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . greater_equal ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ true , true , false ] &gt;","ref":"Explorer.Series.html#greater_equal/2","title":"Explorer.Series.greater_equal/2","type":"function"},{"doc":"Returns the first N elements of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . head ( s ) # Explorer.Series &lt; integer [ 10 ] [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] &gt;","ref":"Explorer.Series.html#head/2","title":"Explorer.Series.head/2","type":"function"},{"doc":"Returns the last element of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . last ( s ) 100","ref":"Explorer.Series.html#last/1","title":"Explorer.Series.last/1","type":"function"},{"doc":"Returns the length of the series. Examples iex&gt; s = Explorer.Series . from_list ( [ ~D[1999-12-31] , ~D[1989-01-01] ] ) iex&gt; Explorer.Series . length ( s ) 2","ref":"Explorer.Series.html#length/1","title":"Explorer.Series.length/1","type":"function"},{"doc":"Returns boolean mask of left &lt; right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . less ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ false , false , true ] &gt;","ref":"Explorer.Series.html#less/2","title":"Explorer.Series.less/2","type":"function"},{"doc":"Returns boolean mask of left &lt;= right , element-wise. Supported dtypes :integer :float :date :datetime Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . less_equal ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ true , true , true ] &gt;","ref":"Explorer.Series.html#less_equal/2","title":"Explorer.Series.less_equal/2","type":"function"},{"doc":"Gets the maximum value of the series. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . max ( s ) 3 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . max ( s ) 3.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . max ( s ) ~D[2021-01-01] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . max ( s ) ~N[2021-01-01 00:00:00.000] iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . max ( s ) ** (ArgumentError) Explorer.Series.max/1 not implemented for dtype :string. Valid dtypes are [:integer, :float, :date, :datetime].","ref":"Explorer.Series.html#max/1","title":"Explorer.Series.max/1","type":"function"},{"doc":"Gets the mean value of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . mean ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . mean ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . mean ( s ) ** (ArgumentError) Explorer.Series.mean/1 not implemented for dtype :date. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#mean/1","title":"Explorer.Series.mean/1","type":"function"},{"doc":"Gets the median value of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . median ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . median ( s ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . median ( s ) ** (ArgumentError) Explorer.Series.median/1 not implemented for dtype :date. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#median/1","title":"Explorer.Series.median/1","type":"function"},{"doc":"Gets the minimum value of the series. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . min ( s ) 1 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . min ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . min ( s ) ~D[1999-12-31] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . min ( s ) ~N[1999-12-31 00:00:00.000] iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . min ( s ) ** (ArgumentError) Explorer.Series.min/1 not implemented for dtype :string. Valid dtypes are [:integer, :float, :date, :datetime].","ref":"Explorer.Series.html#min/1","title":"Explorer.Series.min/1","type":"function"},{"doc":"Multiplies left and right, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float Examples iex&gt; s1 = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; s2 = 11 .. 20 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . multiply ( s1 , s2 ) # Explorer.Series &lt; integer [ 10 ] [ 11 , 24 , 39 , 56 , 75 , 96 , 119 , 144 , 171 , 200 ] &gt; iex&gt; s1 = 1 .. 5 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . multiply ( s1 , 2 ) # Explorer.Series &lt; integer [ 5 ] [ 2 , 4 , 6 , 8 , 10 ] &gt;","ref":"Explorer.Series.html#multiply/2","title":"Explorer.Series.multiply/2","type":"function"},{"doc":"Returns the number of unique values in the series. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;a&quot; , &quot;b&quot; ] ) iex&gt; Explorer.Series . n_distinct ( s ) 2","ref":"Explorer.Series.html#n_distinct/1","title":"Explorer.Series.n_distinct/1","type":"function"},{"doc":"Returns a mask of nil values. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . nil? ( s ) # Explorer.Series &lt; boolean [ 4 ] [ false , false , true , false ] &gt;","ref":"Explorer.Series.html#nil?/1","title":"Explorer.Series.nil?/1","type":"function"},{"doc":"Returns boolean mask of left != right , element-wise. Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 1 , 2 , 4 ] ) iex&gt; Explorer.Series . not_equal ( s1 , s2 ) # Explorer.Series &lt; boolean [ 3 ] [ false , false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . not_equal ( s , 1 ) # Explorer.Series &lt; boolean [ 3 ] [ false , true , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ true , true , false ] ) iex&gt; Explorer.Series . not_equal ( s , true ) # Explorer.Series &lt; boolean [ 3 ] [ false , false , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . not_equal ( s , &quot;a&quot; ) # Explorer.Series &lt; boolean [ 3 ] [ false , true , true ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . not_equal ( s , ~D[1999-12-31] ) # Explorer.Series &lt; boolean [ 2 ] [ true , false ] &gt; iex&gt; s = Explorer.Series . from_list ( [ ~N[2022-01-01 00:00:00] , ~N[2022-01-01 23:00:00] ] ) iex&gt; Explorer.Series . not_equal ( s , ~N[2022-01-01 00:00:00] ) # Explorer.Series &lt; boolean [ 2 ] [ false , true ] &gt;","ref":"Explorer.Series.html#not_equal/2","title":"Explorer.Series.not_equal/2","type":"function"},{"doc":"Returns a mask of not nil values. Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 4 ] ) iex&gt; Explorer.Series . not_nil? ( s ) # Explorer.Series &lt; boolean [ 4 ] [ true , true , false , true ] &gt;","ref":"Explorer.Series.html#not_nil?/1","title":"Explorer.Series.not_nil?/1","type":"function"},{"doc":"Returns a boolean mask of left or right , element-wise Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; mask1 = Explorer.Series . less ( s1 , 2 ) iex&gt; mask2 = Explorer.Series . greater ( s1 , 2 ) iex&gt; Explorer.Series . or ( mask1 , mask2 ) # Explorer.Series &lt; boolean [ 3 ] [ true , false , true ] &gt;","ref":"Explorer.Series.html#or/2","title":"Explorer.Series.or/2","type":"function"},{"doc":"Returns a boolean mask with true where the 'peaks' (series max or min, default max) are. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 4 , 1 , 4 ] ) iex&gt; Explorer.Series . peaks ( s ) # Explorer.Series &lt; boolean [ 5 ] [ false , false , true , false , true ] &gt;","ref":"Explorer.Series.html#peaks/2","title":"Explorer.Series.peaks/2","type":"function"},{"doc":"Raises a numeric series to the power of the exponent. Supported dtypes :integer :float Examples iex&gt; s = [ 8 , 16 , 32 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . pow ( s , 2.0 ) # Explorer.Series &lt; float [ 3 ] [ 64.0 , 256.0 , 1024.0 ] &gt; iex&gt; s = [ 2 , 4 , 6 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . pow ( s , 3 ) # Explorer.Series &lt; integer [ 3 ] [ 8 , 64 , 216 ] &gt; iex&gt; s = [ 2 , 4 , 6 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . pow ( s , - 3.0 ) # Explorer.Series &lt; float [ 3 ] [ 0.125 , 0.015625 , 0.004629629629629629 ] &gt; iex&gt; s = [ 1.0 , 2.0 , 3.0 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . pow ( 3.0 ) # Explorer.Series &lt; float [ 3 ] [ 1.0 , 8.0 , 27.0 ] &gt; iex&gt; s = [ 2.0 , 4.0 , 6.0 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . pow ( 2 ) # Explorer.Series &lt; float [ 3 ] [ 4.0 , 16.0 , 36.0 ] &gt;","ref":"Explorer.Series.html#pow/2","title":"Explorer.Series.pow/2","type":"function"},{"doc":"Gets the given quantile of the series. Supported dtypes :integer :float :date :datetime Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . quantile ( s , 0.2 ) 1 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) 2.0 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ~D[2021-01-01] iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ~N[2021-01-01 00:00:00.000] iex&gt; s = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . quantile ( s , 0.5 ) ** (ArgumentError) Explorer.Series.quantile/2 not implemented for dtype :boolean. Valid dtypes are [:integer, :float, :date, :datetime].","ref":"Explorer.Series.html#quantile/2","title":"Explorer.Series.quantile/2","type":"function"},{"doc":"Reverses the series order. Example iex&gt; s = [ 1 , 2 , 3 ] |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . reverse ( s ) # Explorer.Series &lt; integer [ 3 ] [ 3 , 2 , 1 ] &gt;","ref":"Explorer.Series.html#reverse/1","title":"Explorer.Series.reverse/1","type":"function"},{"doc":"Calculate the rolling max, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . rolling_max ( s , 4 ) # Explorer.Series &lt; integer [ 10 ] [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . rolling_max ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; float [ 10 ] [ 1.0 , 4.0 , 6.0 , 8.0 , 10.0 , 12.0 , 14.0 , 16.0 , 18.0 , 20.0 ] &gt;","ref":"Explorer.Series.html#rolling_max/3","title":"Explorer.Series.rolling_max/3","type":"function"},{"doc":"Calculate the rolling mean, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . rolling_mean ( s , 4 ) # Explorer.Series &lt; float [ 10 ] [ 1.0 , 1.5 , 2.0 , 2.5 , 3.5 , 4.5 , 5.5 , 6.5 , 7.5 , 8.5 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . rolling_mean ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; float [ 10 ] [ 0.5 , 2.5 , 4.0 , 5.5 , 7.0 , 8.5 , 10.0 , 11.5 , 13.0 , 14.5 ] &gt;","ref":"Explorer.Series.html#rolling_mean/3","title":"Explorer.Series.rolling_mean/3","type":"function"},{"doc":"Calculate the rolling min, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . rolling_min ( s , 4 ) # Explorer.Series &lt; integer [ 10 ] [ 1 , 1 , 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . rolling_min ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; float [ 10 ] [ 0.0 , 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 ] &gt;","ref":"Explorer.Series.html#rolling_min/3","title":"Explorer.Series.rolling_min/3","type":"function"},{"doc":"Calculate the rolling sum, given a window size and optional list of weights. Options :weights - An optional list of weights with the same length as the window that will be multiplied elementwise with the values in the window. Defaults to nil . :min_periods - The number of values in the window that should be non-nil before computing a result. If nil , it will be set equal to window size. Defaults to 1 . :center - Set the labels at the center of the window. Defaults to false . Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . rolling_sum ( s , 4 ) # Explorer.Series &lt; integer [ 10 ] [ 1 , 3 , 6 , 10 , 14 , 18 , 22 , 26 , 30 , 34 ] &gt; iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . rolling_sum ( s , 2 , weights : [ 1.0 , 2.0 ] ) # Explorer.Series &lt; float [ 10 ] [ 1.0 , 5.0 , 8.0 , 11.0 , 14.0 , 17.0 , 20.0 , 23.0 , 26.0 , 29.0 ] &gt;","ref":"Explorer.Series.html#rolling_sum/3","title":"Explorer.Series.rolling_sum/3","type":"function"},{"doc":"Returns a random sample of the series. If given an integer as the second argument, it will return N samples. If given a float, it will return that proportion of the series. Can sample with or without replacement. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sample ( s , 10 , seed : 100 ) # Explorer.Series &lt; integer [ 10 ] [ 72 , 33 , 15 , 4 , 16 , 49 , 23 , 96 , 45 , 47 ] &gt; iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . sample ( s , 0.05 , seed : 100 ) # Explorer.Series &lt; integer [ 5 ] [ 68 , 24 , 6 , 8 , 36 ] &gt;","ref":"Explorer.Series.html#sample/3","title":"Explorer.Series.sample/3","type":"function"},{"doc":"Returns a slice of the series, with length elements starting at offset . Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , 1 , 2 ) # Explorer.Series &lt; integer [ 2 ] [ 2 , 3 ] &gt; Negative offsets count from the end of the series. iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , - 3 , 2 ) # Explorer.Series &lt; integer [ 2 ] [ 3 , 4 ] &gt; If the length would run past the end of the series, the result may be shorter than the length. iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 , 4 , 5 ] ) iex&gt; Explorer.Series . slice ( s , - 3 , 4 ) # Explorer.Series &lt; integer [ 3 ] [ 3 , 4 , 5 ] &gt;","ref":"Explorer.Series.html#slice/3","title":"Explorer.Series.slice/3","type":"function"},{"doc":"Sorts the series. Examples iex&gt; s = Explorer.Series . from_list ( [ 9 , 3 , 7 , 1 ] ) iex&gt; s |&gt; Explorer.Series . sort ( ) # Explorer.Series &lt; integer [ 4 ] [ 1 , 3 , 7 , 9 ] &gt;","ref":"Explorer.Series.html#sort/2","title":"Explorer.Series.sort/2","type":"function"},{"doc":"Gets the standard deviation of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . std ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . std ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . std ( s ) ** (ArgumentError) Explorer.Series.std/1 not implemented for dtype :string. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#std/1","title":"Explorer.Series.std/1","type":"function"},{"doc":"Subtracts right from left, element-wise. When mixing floats and integers, the resulting series will have dtype :float . Supported dtypes :integer :float Examples iex&gt; s1 = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; s2 = Explorer.Series . from_list ( [ 4 , 5 , 6 ] ) iex&gt; Explorer.Series . subtract ( s1 , s2 ) # Explorer.Series &lt; integer [ 3 ] [ - 3 , - 3 , - 3 ] &gt;","ref":"Explorer.Series.html#subtract/2","title":"Explorer.Series.subtract/2","type":"function"},{"doc":"Gets the sum of the series. Supported dtypes :integer :float :boolean Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . sum ( s ) 6 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . sum ( s ) 6.0 iex&gt; s = Explorer.Series . from_list ( [ true , false , true ] ) iex&gt; Explorer.Series . sum ( s ) 2 iex&gt; s = Explorer.Series . from_list ( [ ~D[2021-01-01] , ~D[1999-12-31] ] ) iex&gt; Explorer.Series . sum ( s ) ** (ArgumentError) Explorer.Series.sum/1 not implemented for dtype :date. Valid dtypes are [:integer, :float, :boolean].","ref":"Explorer.Series.html#sum/1","title":"Explorer.Series.sum/1","type":"function"},{"doc":"Returns the last N elements of the series. Examples iex&gt; s = 1 .. 100 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; Explorer.Series . tail ( s ) # Explorer.Series &lt; integer [ 10 ] [ 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 ] &gt;","ref":"Explorer.Series.html#tail/2","title":"Explorer.Series.tail/2","type":"function"},{"doc":"Returns the elements at the given indices as a new series. Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;a&quot; , &quot;b&quot; , &quot;c&quot; ] ) iex&gt; Explorer.Series . take ( s , [ 0 , 2 ] ) # Explorer.Series &lt; string [ 2 ] [ &quot;a&quot; , &quot;c&quot; ] &gt;","ref":"Explorer.Series.html#take/2","title":"Explorer.Series.take/2","type":"function"},{"doc":"Takes every n th value in this series, returned as a new series. Examples iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . take_every ( 2 ) # Explorer.Series &lt; integer [ 5 ] [ 1 , 3 , 5 , 7 , 9 ] &gt; If n is bigger than the length of the series, the result is a new series with only the first value of the supplied series. iex&gt; s = 1 .. 10 |&gt; Enum . to_list ( ) |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . take_every ( 20 ) # Explorer.Series &lt; integer [ 1 ] [ 1 ] &gt;","ref":"Explorer.Series.html#take_every/2","title":"Explorer.Series.take_every/2","type":"function"},{"doc":"Converts a series to a list. Examples iex&gt; series = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_list ( series ) [ 1 , 2 , 3 ]","ref":"Explorer.Series.html#to_list/1","title":"Explorer.Series.to_list/1","type":"function"},{"doc":"Converts a series to a Nx.Tensor.t/0 . Options are passed directly to Nx.tensor/2 . Supported dtypes :float :integer Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_tensor ( s ) # Nx.Tensor &lt; s64 [ 3 ] [ 1 , 2 , 3 ] &gt; Tensor options can be passed directly to to_tensor/2 . iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , 3 ] ) iex&gt; Explorer.Series . to_tensor ( s , names : [ :y ] , type : { :f , 64 } ) # Nx.Tensor &lt; f64 [ y : 3 ] [ 1.0 , 2.0 , 3.0 ] &gt;","ref":"Explorer.Series.html#to_tensor/2","title":"Explorer.Series.to_tensor/2","type":"function"},{"doc":"Returns an Explorer.Series where each element is the result of invoking fun on each corresponding element of series . This is an expensive operation meant to enable the use of arbitrary Elixir functions against any backend. The implementation will vary by backend but in most (all?) cases will require converting to an Elixir.List , applying Enum.map/2 , and then converting back to an Explorer.Series . Examples iex&gt; s = Explorer.Series . from_list ( [ &quot;this &quot; , &quot; is&quot; , &quot;great &quot; ] ) iex&gt; Explorer.Series . transform ( s , &amp; String . trim / 1 ) # Explorer.Series &lt; string [ 3 ] [ &quot;this&quot; , &quot;is&quot; , &quot;great&quot; ] &gt; iex&gt; s = Explorer.Series . from_list ( [ &quot;this&quot; , &quot;is&quot; , &quot;great&quot; ] ) iex&gt; Explorer.Series . transform ( s , &amp; String . length / 1 ) # Explorer.Series &lt; integer [ 3 ] [ 4 , 2 , 5 ] &gt;","ref":"Explorer.Series.html#transform/2","title":"Explorer.Series.transform/2","type":"function"},{"doc":"Returns the unique values of the series, but does not maintain order. Faster than distinct/1 . Examples iex&gt; s = [ 1 , 1 , 2 , 2 , 3 , 3 ] |&gt; Explorer.Series . from_list ( ) iex&gt; s |&gt; Explorer.Series . unordered_distinct ( )","ref":"Explorer.Series.html#unordered_distinct/1","title":"Explorer.Series.unordered_distinct/1","type":"function"},{"doc":"Gets the variance of the series. Supported dtypes :integer :float Examples iex&gt; s = Explorer.Series . from_list ( [ 1 , 2 , nil , 3 ] ) iex&gt; Explorer.Series . var ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ 1.0 , 2.0 , nil , 3.0 ] ) iex&gt; Explorer.Series . var ( s ) 1.0 iex&gt; s = Explorer.Series . from_list ( [ ~N[2021-01-01 00:00:00] , ~N[1999-12-31 00:00:00] ] ) iex&gt; Explorer.Series . var ( s ) ** (ArgumentError) Explorer.Series.var/1 not implemented for dtype :datetime. Valid dtypes are [:integer, :float].","ref":"Explorer.Series.html#var/1","title":"Explorer.Series.var/1","type":"function"},{"doc":"","ref":"Explorer.Series.html#t:data/0","title":"Explorer.Series.data/0","type":"type"},{"doc":"","ref":"Explorer.Series.html#t:dtype/0","title":"Explorer.Series.dtype/0","type":"type"},{"doc":"","ref":"Explorer.Series.html#t:t/0","title":"Explorer.Series.t/0","type":"type"},{"doc":"The behaviour for Explorer backends. Each backend is a module with DataFrame and Series submodules that match the respective behaviours for each.","ref":"Explorer.Backend.html","title":"Explorer.Backend","type":"module"},{"doc":"The behaviour for DataFrame backends.","ref":"Explorer.Backend.DataFrame.html","title":"Explorer.Backend.DataFrame","type":"behaviour"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:arrange/2","title":"Explorer.Backend.DataFrame.arrange/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:concat_rows/1","title":"Explorer.Backend.DataFrame.concat_rows/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:distinct/3","title":"Explorer.Backend.DataFrame.distinct/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:drop_nil/2","title":"Explorer.Backend.DataFrame.drop_nil/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dtypes/1","title":"Explorer.Backend.DataFrame.dtypes/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:dummies/2","title":"Explorer.Backend.DataFrame.dummies/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:filter/2","title":"Explorer.Backend.DataFrame.filter/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:from_map/1","title":"Explorer.Backend.DataFrame.from_map/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:group_by/2","title":"Explorer.Backend.DataFrame.group_by/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:head/2","title":"Explorer.Backend.DataFrame.head/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:join/4","title":"Explorer.Backend.DataFrame.join/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:mutate/2","title":"Explorer.Backend.DataFrame.mutate/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:n_cols/1","title":"Explorer.Backend.DataFrame.n_cols/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:n_rows/1","title":"Explorer.Backend.DataFrame.n_rows/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:names/1","title":"Explorer.Backend.DataFrame.names/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:pivot_longer/5","title":"Explorer.Backend.DataFrame.pivot_longer/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:pivot_wider/5","title":"Explorer.Backend.DataFrame.pivot_wider/5","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:pull/2","title":"Explorer.Backend.DataFrame.pull/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:read_csv/12","title":"Explorer.Backend.DataFrame.read_csv/12","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:read_parquet/1","title":"Explorer.Backend.DataFrame.read_parquet/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:rename/2","title":"Explorer.Backend.DataFrame.rename/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:sample/4","title":"Explorer.Backend.DataFrame.sample/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:select/3","title":"Explorer.Backend.DataFrame.select/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:shape/1","title":"Explorer.Backend.DataFrame.shape/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:slice/3","title":"Explorer.Backend.DataFrame.slice/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:summarise/2","title":"Explorer.Backend.DataFrame.summarise/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:tail/2","title":"Explorer.Backend.DataFrame.tail/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:take/2","title":"Explorer.Backend.DataFrame.take/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_binary/3","title":"Explorer.Backend.DataFrame.to_binary/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:to_map/2","title":"Explorer.Backend.DataFrame.to_map/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:ungroup/2","title":"Explorer.Backend.DataFrame.ungroup/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:write_csv/4","title":"Explorer.Backend.DataFrame.write_csv/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#c:write_parquet/2","title":"Explorer.Backend.DataFrame.write_parquet/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:colname/0","title":"Explorer.Backend.DataFrame.colname/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:df/0","title":"Explorer.Backend.DataFrame.df/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:result/1","title":"Explorer.Backend.DataFrame.result/1","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:series/0","title":"Explorer.Backend.DataFrame.series/0","type":"type"},{"doc":"","ref":"Explorer.Backend.DataFrame.html#t:t/0","title":"Explorer.Backend.DataFrame.t/0","type":"type"},{"doc":"The behaviour for series backends.","ref":"Explorer.Backend.Series.html","title":"Explorer.Backend.Series","type":"behaviour"},{"doc":"","ref":"Explorer.Backend.Series.html#c:add/2","title":"Explorer.Backend.Series.add/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:all_equal?/2","title":"Explorer.Backend.Series.all_equal?/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:argsort/2","title":"Explorer.Backend.Series.argsort/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:binary_and/2","title":"Explorer.Backend.Series.binary_and/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:binary_or/2","title":"Explorer.Backend.Series.binary_or/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cast/2","title":"Explorer.Backend.Series.cast/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:concat/2","title":"Explorer.Backend.Series.concat/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:count/1","title":"Explorer.Backend.Series.count/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cum_max/2","title":"Explorer.Backend.Series.cum_max/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cum_min/2","title":"Explorer.Backend.Series.cum_min/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:cum_sum/2","title":"Explorer.Backend.Series.cum_sum/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:distinct/1","title":"Explorer.Backend.Series.distinct/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:divide/2","title":"Explorer.Backend.Series.divide/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:dtype/1","title":"Explorer.Backend.Series.dtype/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:eq/2","title":"Explorer.Backend.Series.eq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:fill_missing/2","title":"Explorer.Backend.Series.fill_missing/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:filter/2","title":"Explorer.Backend.Series.filter/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:from_list/2","title":"Explorer.Backend.Series.from_list/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:get/2","title":"Explorer.Backend.Series.get/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:gt/2","title":"Explorer.Backend.Series.gt/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:gt_eq/2","title":"Explorer.Backend.Series.gt_eq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:head/2","title":"Explorer.Backend.Series.head/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:length/1","title":"Explorer.Backend.Series.length/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:lt/2","title":"Explorer.Backend.Series.lt/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:lt_eq/2","title":"Explorer.Backend.Series.lt_eq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:max/1","title":"Explorer.Backend.Series.max/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:mean/1","title":"Explorer.Backend.Series.mean/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:median/1","title":"Explorer.Backend.Series.median/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:min/1","title":"Explorer.Backend.Series.min/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:multiply/2","title":"Explorer.Backend.Series.multiply/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:n_distinct/1","title":"Explorer.Backend.Series.n_distinct/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:neq/2","title":"Explorer.Backend.Series.neq/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:nil?/1","title":"Explorer.Backend.Series.nil?/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:not_nil?/1","title":"Explorer.Backend.Series.not_nil?/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:peaks/2","title":"Explorer.Backend.Series.peaks/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:pow/2","title":"Explorer.Backend.Series.pow/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:quantile/2","title":"Explorer.Backend.Series.quantile/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:reverse/1","title":"Explorer.Backend.Series.reverse/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:rolling_max/3","title":"Explorer.Backend.Series.rolling_max/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:rolling_mean/3","title":"Explorer.Backend.Series.rolling_mean/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:rolling_min/3","title":"Explorer.Backend.Series.rolling_min/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:rolling_sum/3","title":"Explorer.Backend.Series.rolling_sum/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sample/4","title":"Explorer.Backend.Series.sample/4","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:slice/3","title":"Explorer.Backend.Series.slice/3","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sort/2","title":"Explorer.Backend.Series.sort/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:std/1","title":"Explorer.Backend.Series.std/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:subtract/2","title":"Explorer.Backend.Series.subtract/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:sum/1","title":"Explorer.Backend.Series.sum/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:tail/2","title":"Explorer.Backend.Series.tail/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:take/2","title":"Explorer.Backend.Series.take/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:take_every/2","title":"Explorer.Backend.Series.take_every/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:to_list/1","title":"Explorer.Backend.Series.to_list/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:transform/2","title":"Explorer.Backend.Series.transform/2","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:unordered_distinct/1","title":"Explorer.Backend.Series.unordered_distinct/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#c:var/1","title":"Explorer.Backend.Series.var/1","type":"callback"},{"doc":"","ref":"Explorer.Backend.Series.html#t:df/0","title":"Explorer.Backend.Series.df/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:dtype/0","title":"Explorer.Backend.Series.dtype/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:rolling_option/0","title":"Explorer.Backend.Series.rolling_option/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:s/0","title":"Explorer.Backend.Series.s/0","type":"type"},{"doc":"","ref":"Explorer.Backend.Series.html#t:t/0","title":"Explorer.Backend.Series.t/0","type":"type"},{"doc":"The Explorer backend for Polars.","ref":"Explorer.PolarsBackend.html","title":"Explorer.PolarsBackend","type":"module"}]